{
  Object[] list=(Object[])bin.getNodeMetaData(BINARY_EXP_TARGET);
  Token operation=bin.getOperation();
  int operationType=operation.getType();
  if (operationType == Types.COMPARE_EQUAL || operationType == Types.COMPARE_NOT_EQUAL) {
    CompareToNullExpression compareToNullExpression=null;
    if (isNullConstant(bin.getLeftExpression())) {
      compareToNullExpression=new CompareToNullExpression(staticCompilationTransformer.transform(bin.getRightExpression()),operationType == Types.COMPARE_EQUAL);
    }
 else     if (isNullConstant(bin.getRightExpression())) {
      compareToNullExpression=new CompareToNullExpression(staticCompilationTransformer.transform(bin.getLeftExpression()),operationType == Types.COMPARE_EQUAL);
    }
    if (compareToNullExpression != null) {
      compareToNullExpression.setSourcePosition(bin);
      return compareToNullExpression;
    }
  }
  if (list != null) {
    if (operationType == Types.COMPARE_TO) {
      StaticTypesTypeChooser typeChooser=staticCompilationTransformer.getTypeChooser();
      ClassNode classNode=staticCompilationTransformer.getClassNode();
      ClassNode leftType=typeChooser.resolveType(bin.getLeftExpression(),classNode);
      if (leftType.implementsInterface(ClassHelper.COMPARABLE_TYPE)) {
        ClassNode rightType=typeChooser.resolveType(bin.getRightExpression(),classNode);
        if (rightType.implementsInterface(ClassHelper.COMPARABLE_TYPE)) {
          Expression left=staticCompilationTransformer.transform(bin.getLeftExpression());
          Expression right=staticCompilationTransformer.transform(bin.getRightExpression());
          MethodCallExpression call=new MethodCallExpression(left,"compareTo",new ArgumentListExpression(right));
          call.setImplicitThis(false);
          call.setMethodTarget(COMPARE_TO_METHOD);
          CompareIdentityExpression compareIdentity=new CompareIdentityExpression(left,right);
          compareIdentity.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE,ClassHelper.boolean_TYPE);
          TernaryExpression result=new TernaryExpression(new BooleanExpression(compareIdentity),CONSTANT_ZERO,new TernaryExpression(new BooleanExpression(new CompareToNullExpression(left,true)),CONSTANT_MINUS_ONE,new TernaryExpression(new BooleanExpression(new CompareToNullExpression(right,true)),CONSTANT_ONE,call)));
          compareIdentity.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE,ClassHelper.int_TYPE);
          result.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE,ClassHelper.int_TYPE);
          TernaryExpression expr=(TernaryExpression)result.getFalseExpression();
          expr.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE,ClassHelper.int_TYPE);
          expr.getFalseExpression().putNodeMetaData(StaticTypesMarker.INFERRED_TYPE,ClassHelper.int_TYPE);
          return result;
        }
      }
    }
    boolean isAssignment=StaticTypeCheckingSupport.isAssignment(operationType);
    MethodCallExpression call;
    MethodNode node=(MethodNode)list[0];
    String name=(String)list[1];
    Expression left=staticCompilationTransformer.transform(bin.getLeftExpression());
    Expression right=staticCompilationTransformer.transform(bin.getRightExpression());
    call=new MethodCallExpression(left,name,new ArgumentListExpression(right));
    call.setImplicitThis(false);
    call.setMethodTarget(node);
    MethodNode adapter=StaticCompilationTransformer.BYTECODE_BINARY_ADAPTERS.get(operationType);
    if (adapter != null) {
      ClassExpression sba=new ClassExpression(StaticCompilationTransformer.BYTECODE_ADAPTER_CLASS);
      call=new MethodCallExpression(sba,"compareEquals",new ArgumentListExpression(left,right));
      call.setMethodTarget(adapter);
      call.setImplicitThis(false);
    }
    if (!isAssignment)     return call;
    return new BinaryExpression(left,Token.newSymbol("=",operation.getStartLine(),operation.getStartColumn()),call);
  }
  if (bin.getOperation().getType() == Types.EQUAL && bin.getLeftExpression() instanceof TupleExpression && bin.getRightExpression() instanceof ListExpression) {
    ListOfExpressionsExpression cle=new ListOfExpressionsExpression();
    boolean isDeclaration=bin instanceof DeclarationExpression;
    List<Expression> leftExpressions=((TupleExpression)bin.getLeftExpression()).getExpressions();
    List<Expression> rightExpressions=((ListExpression)bin.getRightExpression()).getExpressions();
    Iterator<Expression> leftIt=leftExpressions.iterator();
    Iterator<Expression> rightIt=rightExpressions.iterator();
    while (leftIt.hasNext()) {
      Expression left=leftIt.next();
      if (rightIt.hasNext()) {
        Expression right=rightIt.next();
        BinaryExpression bexp=isDeclaration ? new DeclarationExpression(left,bin.getOperation(),right) : new BinaryExpression(left,bin.getOperation(),right);
        bexp.setSourcePosition(right);
        cle.addExpression(bexp);
      }
    }
    return staticCompilationTransformer.transform(cle);
  }
  return staticCompilationTransformer.superTransform(bin);
}
