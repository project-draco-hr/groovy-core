{
  Set<ASTNode> accessedMethods=(Set<ASTNode>)node.getNodeMetaData(StaticTypesMarker.PV_METHODS_ACCESS);
  if (accessedMethods == null)   return;
  List<MethodNode> methods=new ArrayList<MethodNode>(node.getMethods());
  Map<MethodNode,MethodNode> privateBridgeMethods=(Map<MethodNode,MethodNode>)node.getNodeMetaData(PRIVATE_BRIDGE_METHODS);
  if (privateBridgeMethods != null) {
    return;
  }
  privateBridgeMethods=new HashMap<MethodNode,MethodNode>();
  final String seed=String.valueOf(System.currentTimeMillis());
  int i=-1;
  for (  MethodNode method : methods) {
    int access=method.getModifiers();
    if (accessedMethods.contains(method)) {
      i++;
      access=(access - Opcodes.ACC_PRIVATE + Opcodes.ACC_SYNTHETIC) + Opcodes.ACC_FINAL;
      Expression arguments;
      if (method.getParameters() == null || method.getParameters().length == 0) {
        arguments=ArgumentListExpression.EMPTY_ARGUMENTS;
      }
 else {
        List<Expression> args=new LinkedList<Expression>();
        for (        Parameter parameter : method.getParameters()) {
          args.add(new VariableExpression(parameter));
        }
        arguments=new ArgumentListExpression(args);
      }
      Expression receiver=method.isStatic() ? new ClassExpression(node) : new VariableExpression("this",node);
      MethodCallExpression mce=new MethodCallExpression(receiver,method.getName(),arguments);
      ExpressionStatement returnStatement=new ExpressionStatement(mce);
      MethodNode bridge=node.addMethod("access$" + seed + i,access,method.getReturnType(),method.getParameters(),method.getExceptions(),returnStatement);
      privateBridgeMethods.put(method,bridge);
      mce.setMethodTarget(method);
      bridge.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));
    }
  }
  node.setNodeMetaData(PRIVATE_BRIDGE_METHODS,privateBridgeMethods);
}
