{
  returnAST=null;
  ASTPair currentAST=new ASTPair();
  AST relationalExpression_AST=null;
  shiftExpression();
  if (inputState.guessing == 0) {
    astFactory.addASTChild(currentAST,returnAST);
  }
{
switch (LA(1)) {
case EOF:
case RBRACK:
case QUESTION:
case LT:
case COMMA:
case GT:
case RPAREN:
case ASSIGN:
case BAND:
case RCURLY:
case SEMI:
case NLS:
case LITERAL_default:
case CLOSURE_OP:
case LOR:
case BOR:
case COLON:
case LITERAL_else:
case LITERAL_in:
case LITERAL_case:
case PLUS_ASSIGN:
case MINUS_ASSIGN:
case STAR_ASSIGN:
case DIV_ASSIGN:
case MOD_ASSIGN:
case SR_ASSIGN:
case BSR_ASSIGN:
case SL_ASSIGN:
case BAND_ASSIGN:
case BXOR_ASSIGN:
case BOR_ASSIGN:
case STAR_STAR_ASSIGN:
case LAND:
case BXOR:
case REGEX_FIND:
case REGEX_MATCH:
case NOT_EQUAL:
case EQUAL:
case COMPARE_TO:
case LE:
case GE:
{
{
switch (LA(1)) {
case LT:
case GT:
case LITERAL_in:
case LE:
case GE:
{
{
switch (LA(1)) {
case LT:
{
                    AST tmp290_AST=null;
                    if (inputState.guessing == 0) {
                      tmp290_AST=astFactory.create(LT(1));
                      astFactory.makeASTRoot(currentAST,tmp290_AST);
                    }
                    match(LT);
                    break;
                  }
case GT:
{
                  AST tmp291_AST=null;
                  if (inputState.guessing == 0) {
                    tmp291_AST=astFactory.create(LT(1));
                    astFactory.makeASTRoot(currentAST,tmp291_AST);
                  }
                  match(GT);
                  break;
                }
case LE:
{
                AST tmp292_AST=null;
                if (inputState.guessing == 0) {
                  tmp292_AST=astFactory.create(LT(1));
                  astFactory.makeASTRoot(currentAST,tmp292_AST);
                }
                match(LE);
                break;
              }
case GE:
{
              AST tmp293_AST=null;
              if (inputState.guessing == 0) {
                tmp293_AST=astFactory.create(LT(1));
                astFactory.makeASTRoot(currentAST,tmp293_AST);
              }
              match(GE);
              break;
            }
case LITERAL_in:
{
            AST tmp294_AST=null;
            if (inputState.guessing == 0) {
              tmp294_AST=astFactory.create(LT(1));
              astFactory.makeASTRoot(currentAST,tmp294_AST);
            }
            match(LITERAL_in);
            break;
          }
default :
{
          throw new NoViableAltException(LT(1),getFilename());
        }
    }
  }
  nls();
  shiftExpression();
  if (inputState.guessing == 0) {
    astFactory.addASTChild(currentAST,returnAST);
  }
  break;
}
case EOF:
case RBRACK:
case QUESTION:
case COMMA:
case RPAREN:
case ASSIGN:
case BAND:
case RCURLY:
case SEMI:
case NLS:
case LITERAL_default:
case CLOSURE_OP:
case LOR:
case BOR:
case COLON:
case LITERAL_else:
case LITERAL_case:
case PLUS_ASSIGN:
case MINUS_ASSIGN:
case STAR_ASSIGN:
case DIV_ASSIGN:
case MOD_ASSIGN:
case SR_ASSIGN:
case BSR_ASSIGN:
case SL_ASSIGN:
case BAND_ASSIGN:
case BXOR_ASSIGN:
case BOR_ASSIGN:
case STAR_STAR_ASSIGN:
case LAND:
case BXOR:
case REGEX_FIND:
case REGEX_MATCH:
case NOT_EQUAL:
case EQUAL:
case COMPARE_TO:
{
break;
}
default :
{
throw new NoViableAltException(LT(1),getFilename());
}
}
}
break;
}
case LITERAL_instanceof:
{
AST tmp295_AST=null;
if (inputState.guessing == 0) {
tmp295_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp295_AST);
}
match(LITERAL_instanceof);
nls();
typeSpec(true);
if (inputState.guessing == 0) {
astFactory.addASTChild(currentAST,returnAST);
}
break;
}
case LITERAL_as:
{
AST tmp296_AST=null;
if (inputState.guessing == 0) {
tmp296_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp296_AST);
}
match(LITERAL_as);
nls();
typeSpec(true);
if (inputState.guessing == 0) {
astFactory.addASTChild(currentAST,returnAST);
}
break;
}
default :
{
throw new NoViableAltException(LT(1),getFilename());
}
}
}
if (inputState.guessing == 0) {
relationalExpression_AST=(AST)currentAST.root;
}
returnAST=relationalExpression_AST;
}
