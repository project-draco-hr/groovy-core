{
  returnAST=null;
  ASTPair currentAST=new ASTPair();
  AST relationalExpression_AST=null;
  shiftExpression();
  astFactory.addASTChild(currentAST,returnAST);
{
switch (LA(1)) {
case EOF:
case FINAL:
case ABSTRACT:
case STRICTFP:
case DEF:
case LITERAL_static:
case AT:
case RBRACK:
case IDENT:
case RPAREN:
case LITERAL_class:
case LITERAL_interface:
case LITERAL_enum:
case QUESTION:
case LT:
case COMMA:
case GT:
case LITERAL_void:
case LITERAL_boolean:
case LITERAL_byte:
case LITERAL_char:
case LITERAL_short:
case LITERAL_int:
case LITERAL_float:
case LITERAL_long:
case LITERAL_double:
case LITERAL_any:
case LITERAL_private:
case LITERAL_public:
case LITERAL_protected:
case LITERAL_transient:
case LITERAL_native:
case LITERAL_threadsafe:
case LITERAL_synchronized:
case LITERAL_volatile:
case ASSIGN:
case LCURLY:
case RCURLY:
case BAND:
case SEMI:
case LITERAL_default:
case BOR:
case LOR:
case COLON:
case LITERAL_else:
case LITERAL_in:
case LITERAL_case:
case PLUS_ASSIGN:
case MINUS_ASSIGN:
case STAR_ASSIGN:
case DIV_ASSIGN:
case MOD_ASSIGN:
case SR_ASSIGN:
case BSR_ASSIGN:
case SL_ASSIGN:
case BAND_ASSIGN:
case BXOR_ASSIGN:
case BOR_ASSIGN:
case STAR_STAR_ASSIGN:
case LAND:
case BXOR:
case REGEX_FIND:
case REGEX_MATCH:
case NOT_EQUAL:
case EQUAL:
case COMPARE_TO:
case LE:
case GE:
case NLS:
{
{
switch (LA(1)) {
case LT:
case GT:
case LITERAL_in:
case LE:
case GE:
{
{
switch (LA(1)) {
case LT:
{
                    AST tmp289_AST=null;
                    tmp289_AST=astFactory.create(LT(1));
                    astFactory.makeASTRoot(currentAST,tmp289_AST);
                    match(LT);
                    break;
                  }
case GT:
{
                  AST tmp290_AST=null;
                  tmp290_AST=astFactory.create(LT(1));
                  astFactory.makeASTRoot(currentAST,tmp290_AST);
                  match(GT);
                  break;
                }
case LE:
{
                AST tmp291_AST=null;
                tmp291_AST=astFactory.create(LT(1));
                astFactory.makeASTRoot(currentAST,tmp291_AST);
                match(LE);
                break;
              }
case GE:
{
              AST tmp292_AST=null;
              tmp292_AST=astFactory.create(LT(1));
              astFactory.makeASTRoot(currentAST,tmp292_AST);
              match(GE);
              break;
            }
case LITERAL_in:
{
            AST tmp293_AST=null;
            tmp293_AST=astFactory.create(LT(1));
            astFactory.makeASTRoot(currentAST,tmp293_AST);
            match(LITERAL_in);
            break;
          }
default :
{
          throw new NoViableAltException(LT(1),getFilename());
        }
    }
  }
  nls();
  shiftExpression();
  astFactory.addASTChild(currentAST,returnAST);
  break;
}
case EOF:
case FINAL:
case ABSTRACT:
case STRICTFP:
case DEF:
case LITERAL_static:
case AT:
case RBRACK:
case IDENT:
case RPAREN:
case LITERAL_class:
case LITERAL_interface:
case LITERAL_enum:
case QUESTION:
case COMMA:
case LITERAL_void:
case LITERAL_boolean:
case LITERAL_byte:
case LITERAL_char:
case LITERAL_short:
case LITERAL_int:
case LITERAL_float:
case LITERAL_long:
case LITERAL_double:
case LITERAL_any:
case LITERAL_private:
case LITERAL_public:
case LITERAL_protected:
case LITERAL_transient:
case LITERAL_native:
case LITERAL_threadsafe:
case LITERAL_synchronized:
case LITERAL_volatile:
case ASSIGN:
case LCURLY:
case RCURLY:
case BAND:
case SEMI:
case LITERAL_default:
case BOR:
case LOR:
case COLON:
case LITERAL_else:
case LITERAL_case:
case PLUS_ASSIGN:
case MINUS_ASSIGN:
case STAR_ASSIGN:
case DIV_ASSIGN:
case MOD_ASSIGN:
case SR_ASSIGN:
case BSR_ASSIGN:
case SL_ASSIGN:
case BAND_ASSIGN:
case BXOR_ASSIGN:
case BOR_ASSIGN:
case STAR_STAR_ASSIGN:
case LAND:
case BXOR:
case REGEX_FIND:
case REGEX_MATCH:
case NOT_EQUAL:
case EQUAL:
case COMPARE_TO:
case NLS:
{
break;
}
default :
{
throw new NoViableAltException(LT(1),getFilename());
}
}
}
break;
}
case LITERAL_instanceof:
{
AST tmp294_AST=null;
tmp294_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp294_AST);
match(LITERAL_instanceof);
nls();
typeSpec(true);
astFactory.addASTChild(currentAST,returnAST);
break;
}
case LITERAL_as:
{
AST tmp295_AST=null;
tmp295_AST=astFactory.create(LT(1));
astFactory.makeASTRoot(currentAST,tmp295_AST);
match(LITERAL_as);
nls();
typeSpec(true);
astFactory.addASTChild(currentAST,returnAST);
break;
}
default :
{
throw new NoViableAltException(LT(1),getFilename());
}
}
}
relationalExpression_AST=(AST)currentAST.root;
returnAST=relationalExpression_AST;
}
