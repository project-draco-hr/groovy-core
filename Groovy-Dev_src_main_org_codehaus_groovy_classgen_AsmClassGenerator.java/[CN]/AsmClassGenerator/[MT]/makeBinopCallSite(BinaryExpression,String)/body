{
  final Expression left=bin.getLeftExpression();
  final Expression right=bin.getRightExpression();
  if (!names.contains(message)) {
    makeBinopCallSite(left,message,right);
  }
 else {
    improveExprType(bin);
    ClassNode type1=getLHSType(left);
    ClassNode type2=getLHSType(right);
    if (ClassHelper.isNumberType(type1) && ClassHelper.isNumberType(type2)) {
      ClassNode prim1=ClassHelper.getUnwrapper(type1);
      ClassNode prim2=ClassHelper.getUnwrapper(type2);
      if (message.equals("div") && prim1 == ClassHelper.int_TYPE && prim2 == ClassHelper.int_TYPE) {
        makeBinopCallSite(left,message,right);
        return;
      }
      ClassNode retType;
      if (prim1 == ClassHelper.double_TYPE || prim2 == ClassHelper.double_TYPE) {
        retType=ClassHelper.double_TYPE;
      }
 else       if (prim1 == ClassHelper.float_TYPE || prim2 == ClassHelper.float_TYPE) {
        retType=ClassHelper.double_TYPE;
      }
 else       if (prim1 == ClassHelper.long_TYPE || prim2 == ClassHelper.long_TYPE) {
        retType=ClassHelper.long_TYPE;
      }
 else       retType=ClassHelper.int_TYPE;
      if (retType == ClassHelper.double_TYPE && !basic.contains(message)) {
        makeBinopCallSite(left,message,right);
        return;
      }
      if (left instanceof ConstantExpression) {
        mv.visitLdcInsn(((ConstantExpression)left).getValue());
      }
 else {
        visitAndAutoboxBoolean(left);
        helper.unbox(prim1);
      }
      if (right instanceof ConstantExpression) {
        mv.visitLdcInsn(((ConstantExpression)right).getValue());
      }
 else {
        visitAndAutoboxBoolean(right);
        helper.unbox(prim2);
      }
      mv.visitMethodInsn(INVOKESTATIC,"org/codehaus/groovy/runtime/typehandling/NumberMathModificationInfo",message,"(" + BytecodeHelper.getTypeDescription(prim1) + BytecodeHelper.getTypeDescription(prim2)+ ")"+ BytecodeHelper.getTypeDescription(retType));
      helper.box(retType);
    }
 else {
      makeBinopCallSite(left,message,right);
    }
  }
}
