{
  ClassNode enumRef=enumClass.getPlainNodeReference();
  Parameter[] parameter=new Parameter[]{new Parameter(ClassHelper.OBJECT_TYPE.makeArray(),"para")};
  MethodNode initMethod=new MethodNode("$INIT",PUBLIC_FS | Opcodes.ACC_SYNTHETIC,enumRef,parameter,ClassNode.EMPTY_ARRAY,null);
  initMethod.setSynthetic(true);
  ConstructorCallExpression cce=new ConstructorCallExpression(ClassNode.THIS,new ArgumentListExpression(new SpreadExpression(new VariableExpression("para"))));
  BlockStatement code=new BlockStatement();
  code.addStatement(new ReturnStatement(cce));
  initMethod.setCode(code);
  enumClass.addMethod(initMethod);
  List<FieldNode> fields=enumClass.getFields();
  List<Expression> arrayInit=new ArrayList<Expression>();
  int value=-1;
  Token assign=Token.newSymbol(Types.ASSIGN,-1,-1);
  List<Statement> block=new ArrayList<Statement>();
  FieldNode tempMin=null;
  FieldNode tempMax=null;
  for (  FieldNode field : fields) {
    if ((field.getModifiers() & Opcodes.ACC_ENUM) == 0)     continue;
    value++;
    if (tempMin == null)     tempMin=field;
    tempMax=field;
    ClassNode enumBase=enumClass;
    ArgumentListExpression args=new ArgumentListExpression();
    args.addExpression(new ConstantExpression(field.getName()));
    args.addExpression(new ConstantExpression(value));
    if (field.getInitialExpression() != null) {
      ListExpression oldArgs=(ListExpression)field.getInitialExpression();
      for (      Expression exp : oldArgs.getExpressions()) {
        if (exp instanceof MapEntryExpression) {
          String msg="The usage of a map entry expression to initialize an Enum is currently not supported, please use an explicit map instead.";
          sourceUnit.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(new SyntaxException(msg + '\n',exp.getLineNumber(),exp.getColumnNumber()),sourceUnit));
          continue;
        }
        InnerClassNode inner=null;
        if (exp instanceof ClassExpression) {
          ClassExpression clazzExp=(ClassExpression)exp;
          ClassNode ref=clazzExp.getType();
          if (ref instanceof EnumConstantClassNode) {
            inner=(InnerClassNode)ref;
          }
        }
        if (inner != null) {
          if (inner.getVariableScope() == null) {
            enumBase=inner;
            initMethod.setModifiers(initMethod.getModifiers() & ~Opcodes.ACC_FINAL);
            continue;
          }
        }
        args.addExpression(exp);
      }
    }
    field.setInitialValueExpression(null);
    block.add(new ExpressionStatement(new BinaryExpression(new FieldExpression(field),assign,new StaticMethodCallExpression(enumBase,"$INIT",args))));
    arrayInit.add(new FieldExpression(field));
  }
  if (!isAic) {
    if (tempMin != null) {
      block.add(new ExpressionStatement(new BinaryExpression(new FieldExpression(minValue),assign,new FieldExpression(tempMin))));
      block.add(new ExpressionStatement(new BinaryExpression(new FieldExpression(maxValue),assign,new FieldExpression(tempMax))));
      enumClass.addField(minValue);
      enumClass.addField(maxValue);
    }
    block.add(new ExpressionStatement(new BinaryExpression(new FieldExpression(values),assign,new ArrayExpression(enumClass,arrayInit))));
    enumClass.addField(values);
  }
  enumClass.addStaticInitializerStatements(block,true);
}
