{
  final FieldNode constructorField=cNode.addField("$map$constructor",ACC_PRIVATE | ACC_SYNTHETIC,ClassHelper.boolean_TYPE,null);
  final FieldExpression constructorStyle=new FieldExpression(constructorField);
  if (cNode.getDeclaredConstructors().size() != 0) {
    throw new RuntimeException(MY_TYPE_NAME + " does not allow explicit constructors");
  }
  final BlockStatement body=new BlockStatement();
  List<PropertyNode> list=cNode.getProperties();
  final VariableExpression args=new VariableExpression("args");
  for (  PropertyNode pNode : list) {
    body.addStatement(createConstructorStatement(pNode));
  }
  final List<FieldNode> fList=cNode.getFields();
  for (  FieldNode fNode : fList) {
    if (!fNode.isPublic() && !fNode.getName().contains("$") && (cNode.getProperty(fNode.getName()) == null)) {
      body.addStatement(createConstructorStatementDefault(fNode));
    }
  }
  body.addStatement(assignStatement(constructorStyle,ConstantExpression.TRUE));
  final Parameter[] params=new Parameter[]{new Parameter(HASHMAP_TYPE,"args")};
  cNode.addConstructor(new ConstructorNode(ACC_PUBLIC,params,ClassNode.EMPTY_ARRAY,new IfStatement(equalsNullExpr(args),new EmptyStatement(),body)));
  final MapExpression argMap=new MapExpression();
  final Parameter[] orderedParams=new Parameter[list.size()];
  int index=0;
  for (  PropertyNode pNode : list) {
    orderedParams[index++]=new Parameter(pNode.getField().getType(),pNode.getField().getName());
    argMap.addMapEntryExpression(new ConstantExpression(pNode.getName()),new VariableExpression(pNode.getName()));
  }
  final BlockStatement orderedBody=new BlockStatement();
  orderedBody.addStatement(new ExpressionStatement(new ConstructorCallExpression(ClassNode.THIS,argMap)));
  orderedBody.addStatement(assignStatement(constructorStyle,ConstantExpression.FALSE));
  cNode.addConstructor(new ConstructorNode(ACC_PUBLIC,orderedParams,ClassNode.EMPTY_ARRAY,orderedBody));
}
