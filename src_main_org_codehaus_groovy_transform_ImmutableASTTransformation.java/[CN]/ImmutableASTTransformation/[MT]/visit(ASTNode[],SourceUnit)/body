{
  if (nodes.length != 2 || !(nodes[0] instanceof AnnotationNode) || !(nodes[1] instanceof AnnotatedNode)) {
    throw new RuntimeException("Internal error: expecting [AnnotationNode, AnnotatedNode] but got: " + Arrays.asList(nodes));
  }
  AnnotatedNode parent=(AnnotatedNode)nodes[1];
  AnnotationNode node=(AnnotationNode)nodes[0];
  if (!MY_TYPE.equals(node.getClassNode()))   return;
  List<PropertyNode> newNodes=new ArrayList<PropertyNode>();
  if (parent instanceof ClassNode) {
    ClassNode cNode=(ClassNode)parent;
    String cName=cNode.getName();
    if (cNode.isInterface()) {
      throw new RuntimeException("Error processing interface '" + cName + "'. "+ MY_TYPE_NAME+ " not allowed for interfaces.");
    }
    if ((cNode.getModifiers() & ACC_FINAL) == 0) {
      cNode.setModifiers(cNode.getModifiers() | ACC_FINAL);
    }
    final List<PropertyNode> pList=getInstanceProperties(cNode);
    for (    PropertyNode pNode : pList) {
      adjustPropertyForImmutability(pNode,newNodes);
    }
    for (    PropertyNode pNode : newNodes) {
      pList.remove(pNode);
      addProperty(cNode,pNode);
    }
    final List<FieldNode> fList=cNode.getFields();
    for (    FieldNode fNode : fList) {
      ensureNotPublic(cName,fNode);
    }
    createConstructor(cNode);
    createHashCode(cNode);
    createEquals(cNode);
    createToString(cNode);
  }
}
