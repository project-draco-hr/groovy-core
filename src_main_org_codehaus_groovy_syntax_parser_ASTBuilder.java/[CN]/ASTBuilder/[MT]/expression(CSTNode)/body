{
switch (expressionRoot.getToken().getType()) {
case (Token.COMPARE_EQUAL):
case (Token.COMPARE_NOT_EQUAL):
case (Token.COMPARE_IDENTICAL):
case (Token.COMPARE_LESS_THAN):
case (Token.COMPARE_LESS_THAN_EQUAL):
case (Token.COMPARE_GREATER_THAN):
case (Token.COMPARE_GREATER_THAN_EQUAL):
case (Token.PLUS):
case (Token.MINUS):
case (Token.DIVIDE):
case (Token.MULTIPLY):
case (Token.MOD):
case (Token.EQUAL):
{
      return binaryExpression(expressionRoot);
    }
case (Token.DOT_DOT):
{
    return rangeExpression(expressionRoot);
  }
case (Token.SINGLE_QUOTE_STRING):
case (Token.DOUBLE_QUOTE_STRING):
case (Token.INTEGER_NUMBER):
case (Token.FLOAT_NUMBER):
case (Token.KEYWORD_NULL):
case (Token.KEYWORD_TRUE):
case (Token.KEYWORD_FALSE):
{
  return constantExpression(expressionRoot);
}
case (Token.IDENTIFIER):
{
return variableOrClassExpression(expressionRoot);
}
case (Token.KEYWORD_THIS):
case (Token.KEYWORD_SUPER):
{
return variableExpression(expressionRoot);
}
case (Token.DOT):
{
return propertyExpression(expressionRoot);
}
case (Token.LEFT_SQUARE_BRACKET):
{
return listExpression(expressionRoot);
}
case (Token.LEFT_PARENTHESIS):
{
return methodCallExpression(expressionRoot);
}
}
throw new RuntimeException(expressionRoot.getToken().getStartLine() + ": cannot create expression for node: " + expressionRoot);
}
