{
switch (expressionRoot.getToken().getType()) {
case (Token.MINUS):
{
      if (expressionRoot.getChildren().length == 1) {
        return negationExpression(expressionRoot);
      }
    }
case (Token.COMPARE_EQUAL):
case (Token.COMPARE_NOT_EQUAL):
case (Token.COMPARE_IDENTICAL):
case (Token.COMPARE_LESS_THAN):
case (Token.COMPARE_LESS_THAN_EQUAL):
case (Token.COMPARE_GREATER_THAN):
case (Token.COMPARE_GREATER_THAN_EQUAL):
case (Token.PLUS):
case (Token.PLUS_EQUAL):
case (Token.MINUS_EQUAL):
case (Token.MULTIPLY):
case (Token.MULTIPLY_EQUAL):
case (Token.DIVIDE):
case (Token.DIVIDE_EQUAL):
case (Token.MOD):
case (Token.MOD_EQUAL):
case (Token.EQUAL):
case (Token.KEYWORD_INSTANCEOF):
case (Token.LOGICAL_AND):
case (Token.LOGICAL_OR):
case (Token.FIND_REGEX):
case (Token.MATCH_REGEX):
case (Token.COMPARE_TO):
case (Token.LEFT_SQUARE_BRACKET):
case (Token.LEFT_SHIFT):
case (Token.RIGHT_SHIFT):
{
    return binaryExpression(expressionRoot);
  }
case (Token.QUESTION):
{
  return ternaryExpression(expressionRoot);
}
case (Token.SYNTH_POSTFIX):
{
return postfixExpression(expressionRoot);
}
case (Token.SYNTH_PREFIX):
{
return prefixExpression(expressionRoot);
}
case (Token.DOT_DOT):
{
return rangeExpression(expressionRoot,true);
}
case (Token.DOT_DOT_DOT):
{
return rangeExpression(expressionRoot,false);
}
case (Token.SINGLE_QUOTE_STRING):
case (Token.INTEGER_NUMBER):
case (Token.FLOAT_NUMBER):
case (Token.KEYWORD_NULL):
case (Token.KEYWORD_TRUE):
case (Token.KEYWORD_FALSE):
{
return constantExpression(expressionRoot);
}
case (Token.DOUBLE_QUOTE_STRING):
{
GStringExpression gstring=compositeStringExpression(expressionRoot);
if (gstring.isConstantString()) {
return gstring.asConstantString();
}
return gstring;
}
case (Token.PATTERN_REGEX):
{
Expression string=expression(expressionRoot.getChild(0));
RegexExpression regex=new RegexExpression(string);
return regex;
}
case (Token.IDENTIFIER):
{
Expression expression=variableOrClassExpression(expressionRoot);
return expression;
}
case (Token.KEYWORD_THIS):
case (Token.KEYWORD_SUPER):
{
return variableExpression(expressionRoot);
}
case (Token.DOT):
{
return propertyExpression(expressionRoot);
}
case (Token.NAVIGATE):
{
return safePropertyExpression(expressionRoot);
}
case (Token.SYNTH_LIST):
{
return listExpression(expressionRoot);
}
case (Token.SYNTH_MAP):
{
return mapExpression(expressionRoot);
}
case (Token.LEFT_PARENTHESIS):
{
return methodCallExpression(expressionRoot);
}
case (Token.LEFT_CURLY_BRACE):
{
return closureExpression(expressionRoot);
}
case (Token.KEYWORD_NEW):
{
return newExpression(expressionRoot);
}
case (Token.NOT):
{
return notExpression(expressionRoot);
}
case (Token.SYNTH_CAST):
{
return castExpression(expressionRoot);
}
}
throw new RuntimeException(expressionRoot.getToken().getStartLine() + ": cannot create expression for node: " + expressionRoot);
}
