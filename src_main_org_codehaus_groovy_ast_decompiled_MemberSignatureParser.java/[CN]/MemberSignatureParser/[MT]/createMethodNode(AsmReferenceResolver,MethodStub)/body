{
  GenericsType[] typeParameters=null;
  Type[] argumentTypes=Type.getArgumentTypes(method.desc);
  final ClassNode[] parameterTypes=new ClassNode[argumentTypes.length];
  for (int i=0; i < argumentTypes.length; i++) {
    parameterTypes[i]=resolver.resolveType(argumentTypes[i]);
  }
  final ClassNode[] exceptions=new ClassNode[method.exceptions.length];
  for (int i=0; i < method.exceptions.length; i++) {
    exceptions[i]=resolver.resolveClass(AsmDecompiler.fromInternalName(method.exceptions[i]));
  }
  final Reference<ClassNode> returnType=new Reference<ClassNode>(resolver.resolveType(Type.getReturnType(method.desc)));
  if (method.signature != null) {
    FormalParameterParser v=new FormalParameterParser(resolver){
      int paramIndex=0;
      @Override public SignatureVisitor visitParameterType(){
        return new TypeSignatureParser(resolver){
          @Override void finished(          ClassNode result){
            parameterTypes[paramIndex++]=result;
          }
        }
;
      }
      @Override public SignatureVisitor visitReturnType(){
        return new TypeSignatureParser(resolver){
          @Override void finished(          ClassNode result){
            returnType.set(result);
          }
        }
;
      }
      int exceptionIndex=0;
      @Override public SignatureVisitor visitExceptionType(){
        return new TypeSignatureParser(resolver){
          @Override void finished(          ClassNode result){
            exceptions[exceptionIndex++]=result;
          }
        }
;
      }
    }
;
    new SignatureReader(method.signature).accept(v);
    typeParameters=v.getTypeParameters();
  }
  Parameter[] parameters=new Parameter[parameterTypes.length];
  for (int i=0; i < parameterTypes.length; i++) {
    parameters[i]=new Parameter(parameterTypes[i],"param" + i);
  }
  for (  Map.Entry<Integer,List<AnnotationStub>> entry : method.parameterAnnotations.entrySet()) {
    for (    AnnotationStub stub : entry.getValue()) {
      parameters[entry.getKey()].addAnnotation(Annotations.createAnnotationNode(stub,resolver));
    }
  }
  MethodNode result;
  if ("<init>".equals(method.methodName)) {
    result=new ConstructorNode(method.accessModifiers,parameters,exceptions,null);
  }
 else {
    result=new MethodNode(method.methodName,method.accessModifiers,returnType.get(),parameters,exceptions,null);
    if (method.annotationDefault != null) {
      result.setCode(new ReturnStatement(new ConstantExpression(method.annotationDefault)));
      result.setAnnotationDefault(true);
    }
  }
  result.setGenericsTypes(typeParameters);
  return result;
}
