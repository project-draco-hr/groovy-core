{
  ClassNode helper=new InnerClassNode(cNode,helperClassName(cNode),ACC_PUBLIC | ACC_STATIC | ACC_ABSTRACT| ACC_SYNTHETIC,ClassHelper.OBJECT_TYPE,ClassNode.EMPTY_ARRAY,null);
  cNode.setModifiers(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);
  MethodNode initializer=new MethodNode("$init$",ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,ClassHelper.VOID_TYPE,new Parameter[]{new Parameter(cNode,"$this")},ClassNode.EMPTY_ARRAY,new BlockStatement());
  helper.addMethod(initializer);
  generatePropertyMethods(cNode);
  Map<String,MethodNode> methods=cNode.getDeclaredMethodsMap();
  for (  MethodNode methodNode : methods.values()) {
    if (methodNode.getDeclaringClass() == cNode) {
      helper.addMethod(processMethod(cNode,methodNode));
    }
  }
  List<FieldNode> fields=new ArrayList<FieldNode>(cNode.getFields());
  ClassNode fieldHelper=null;
  if (cNode.getFields() != null) {
    fieldHelper=new InnerClassNode(cNode,fieldHelperClassName(cNode),ACC_STATIC | ACC_PUBLIC | ACC_INTERFACE| ACC_ABSTRACT,ClassHelper.OBJECT_TYPE);
  }
  for (  FieldNode field : fields) {
    processField(field,initializer,fieldHelper);
  }
  cNode.getProperties().clear();
  for (  FieldNode field : fields) {
    cNode.removeField(field.getName());
  }
  unit.getAST().addClass(helper);
  if (fieldHelper != null) {
    unit.getAST().addClass(fieldHelper);
  }
}
