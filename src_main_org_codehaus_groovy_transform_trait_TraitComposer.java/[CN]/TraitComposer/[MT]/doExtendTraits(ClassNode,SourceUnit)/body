{
  boolean isItselfTrait=TraitConstants.isTrait(cNode);
  if (isItselfTrait) {
    checkTraitAllowed(cNode,unit);
    return;
  }
  Set<ClassNode> interfaces=cNode.getAllInterfaces();
  for (  ClassNode trait : interfaces) {
    List<AnnotationNode> traitAnn=trait.getAnnotations(TraitConstants.TRAIT_CLASSNODE);
    if (traitAnn != null && !traitAnn.isEmpty() && !cNode.getNameWithoutPackage().endsWith(TraitConstants.TRAIT_HELPER)) {
      Iterator<InnerClassNode> innerClasses=trait.redirect().getInnerClasses();
      if (innerClasses != null && innerClasses.hasNext()) {
        ClassNode helperClassNode=null;
        ClassNode fieldHelperClassNode=null;
        while (innerClasses.hasNext()) {
          ClassNode icn=innerClasses.next();
          if (icn.getName().endsWith(TraitConstants.FIELD_HELPER)) {
            fieldHelperClassNode=icn;
          }
 else           if (icn.getName().endsWith(TraitConstants.TRAIT_HELPER)) {
            helperClassNode=icn;
          }
        }
        applyTrait(trait,cNode,helperClassNode,fieldHelperClassNode);
      }
 else {
        applyPrecompiledTrait(trait,cNode);
      }
    }
  }
}
