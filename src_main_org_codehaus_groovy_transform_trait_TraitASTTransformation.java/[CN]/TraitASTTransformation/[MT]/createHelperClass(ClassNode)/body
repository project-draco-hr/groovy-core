{
  ClassNode helper=new InnerClassNode(cNode,TraitConstants.helperClassName(cNode),ACC_PUBLIC | ACC_STATIC | ACC_ABSTRACT| ACC_SYNTHETIC,ClassHelper.OBJECT_TYPE,ClassNode.EMPTY_ARRAY,null);
  cNode.setModifiers(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);
  ClassNode superClass=cNode.getSuperClass();
  if (TraitConstants.isTrait(superClass)) {
    cNode.setSuperClass(ClassHelper.OBJECT_TYPE.getPlainNodeReference());
    cNode.addInterface(superClass);
  }
  MethodNode initializer=new MethodNode(TraitConstants.STATIC_INIT_METHOD,ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,ClassHelper.VOID_TYPE,new Parameter[]{new Parameter(cNode.getPlainNodeReference(),TraitConstants.THIS_OBJECT)},ClassNode.EMPTY_ARRAY,new BlockStatement());
  fixGenerics(initializer,cNode);
  helper.addMethod(initializer);
  generatePropertyMethods(cNode);
  List<FieldNode> fields=new ArrayList<FieldNode>();
  for (  FieldNode field : cNode.getFields()) {
    if (!"metaClass".equals(field.getName()) && (!field.isSynthetic() || field.getName().indexOf('$') < 0)) {
      fields.add(field);
    }
  }
  ClassNode fieldHelper=null;
  if (!fields.isEmpty()) {
    fieldHelper=new InnerClassNode(cNode,TraitConstants.fieldHelperClassName(cNode),ACC_STATIC | ACC_PUBLIC | ACC_INTERFACE| ACC_ABSTRACT,ClassHelper.OBJECT_TYPE);
  }
  List<MethodNode> methods=cNode.getMethods();
  for (  final MethodNode methodNode : methods) {
    boolean declared=methodNode.getDeclaringClass() == cNode;
    if (declared) {
      if (!methodNode.isSynthetic() && (methodNode.isPrivate() || methodNode.isProtected())) {
        unit.addError(new SyntaxException("Cannot have " + (methodNode.isPrivate() ? "private" : "protected") + " method in a trait ("+ cNode.getName()+ "#"+ methodNode.getTypeDescriptor()+ ")",methodNode.getLineNumber(),methodNode.getColumnNumber()));
        return;
      }
      helper.addMethod(processMethod(cNode,methodNode,fieldHelper));
    }
  }
  for (  FieldNode field : fields) {
    processField(field,initializer,fieldHelper);
  }
  cNode.getProperties().clear();
  fields=new ArrayList<FieldNode>(cNode.getFields());
  for (  FieldNode field : fields) {
    cNode.removeField(field.getName());
  }
  unit.getAST().addClass(helper);
  if (fieldHelper != null) {
    unit.getAST().addClass(fieldHelper);
  }
}
