{
  Class superClass=instance instanceof Class ? (Class)instance : instance.getClass();
  while (superClass != Object.class) {
    final MetaMethod method=findMethodInClassHeirarchy(methodName,arguments,superClass);
    if (method != null) {
      onSuperMethodFoundInHierarchy(method);
      return method.invoke(instance,arguments);
    }
    superClass=superClass.getSuperclass();
  }
  final Object[] invokeMethodArgs={methodName,arguments};
  final MetaMethod method=findMethodInClassHeirarchy(ExpandoMetaClass.INVOKE_METHOD_METHOD,invokeMethodArgs,theClass);
  if (method != null && method instanceof ClosureMetaMethod) {
    onInvokeMethodFoundInHierarchy(method);
    return method.invoke(instance,invokeMethodArgs);
  }
  if (methodMissing != null) {
    try {
      return methodMissing.invoke(instance,new Object[]{methodName,arguments});
    }
 catch (    InvokerInvocationException iie) {
      if (methodMissing instanceof ClosureMetaMethod && iie.getCause() instanceof MissingMethodException) {
        MissingMethodException mme=(MissingMethodException)iie.getCause();
        throw new MissingMethodExecutionFailed(mme.getMethod(),mme.getClass(),mme.getArguments(),mme.isStatic(),mme);
      }
      throw iie;
    }
  }
 else   if (original != null)   throw original;
 else   throw new MissingMethodExceptionNoStack(methodName,theClass,arguments,false);
}
