{
  checkInitalised();
  if (object == null) {
    throw new NullPointerException("Cannot invoke method: " + methodName + " on null object");
  }
  if (log.isLoggable(Level.FINER)) {
    MetaClassHelper.logMethodCall(object,methodName,originalArguments);
  }
  final Object[] arguments=originalArguments == null ? EMPTY_ARGUMENTS : originalArguments;
  final Class[] argClasses=MetaClassHelper.convertToTypeArray(arguments);
  unwrap(arguments);
  MetaMethod method=getMethodWithCaching(sender,methodName,argClasses,isCallToSuper);
  if (method == null && arguments.length == 1 && arguments[0] instanceof List) {
    Object[] newArguments=((List)arguments[0]).toArray();
    Class[] newArgClasses=MetaClassHelper.convertToTypeArray(newArguments);
    method=getMethodWithCaching(sender,methodName,newArgClasses,isCallToSuper);
    if (method != null) {
      method=new TransformMetaMethod(method){
        public Object invoke(        Object object,        Object[] arguments){
          Object firstArgument=arguments[0];
          List list=(List)firstArgument;
          arguments=list.toArray();
          return super.invoke(object,arguments);
        }
      }
;
    }
  }
  final boolean isClosure=object instanceof Closure;
  if (isClosure) {
    final Closure closure=(Closure)object;
    final Object owner=closure.getOwner();
    if (CLOSURE_CALL_METHOD.equals(methodName) || CLOSURE_DO_CALL_METHOD.equals(methodName)) {
      final Class objectClass=object.getClass();
      if (objectClass == MethodClosure.class) {
        final MethodClosure mc=(MethodClosure)object;
        methodName=mc.getMethod();
        final Class ownerClass=owner instanceof Class ? (Class)owner : owner.getClass();
        final MetaClass ownerMetaClass=registry.getMetaClass(ownerClass);
        return ownerMetaClass.invokeMethod(ownerClass,owner,methodName,arguments,false,false);
      }
 else       if (objectClass == CurriedClosure.class) {
        final CurriedClosure cc=(CurriedClosure)object;
        final Object[] curriedArguments=cc.getUncurriedArguments(arguments);
        final Class ownerClass=owner instanceof Class ? (Class)owner : owner.getClass();
        final MetaClass ownerMetaClass=registry.getMetaClass(ownerClass);
        return ownerMetaClass.invokeMethod(owner,methodName,curriedArguments);
      }
    }
 else     if (CLOSURE_CURRY_METHOD.equals(methodName)) {
      return closure.curry(arguments);
    }
    final Object delegate=closure.getDelegate();
    final boolean isClosureNotOwner=owner != closure;
    final int resolveStrategy=closure.getResolveStrategy();
switch (resolveStrategy) {
case Closure.TO_SELF:
      method=closure.getMetaClass().pickMethod(methodName,argClasses);
    if (method != null)     return method.invoke(closure,arguments);
  break;
case Closure.DELEGATE_ONLY:
if (method == null && delegate != closure && delegate != null) {
  MetaClass delegateMetaClass=lookupObjectMetaClass(delegate);
  method=delegateMetaClass.pickMethod(methodName,argClasses);
  if (method != null)   return delegateMetaClass.invokeMethod(delegate,methodName,originalArguments);
 else   if (delegate != closure && (delegate instanceof GroovyObject)) {
    return invokeMethodOnGroovyObject(methodName,originalArguments,delegate);
  }
}
break;
case Closure.OWNER_ONLY:
if (method == null && owner != closure) {
MetaClass ownerMetaClass=lookupObjectMetaClass(owner);
return ownerMetaClass.invokeMethod(owner,methodName,originalArguments);
}
break;
case Closure.DELEGATE_FIRST:
if (method == null && delegate != closure && delegate != null) {
MetaClass delegateMetaClass=lookupObjectMetaClass(delegate);
method=delegateMetaClass.pickMethod(methodName,argClasses);
if (method != null) return delegateMetaClass.invokeMethod(delegate,methodName,originalArguments);
}
if (method == null && owner != closure) {
MetaClass ownerMetaClass=lookupObjectMetaClass(owner);
method=ownerMetaClass.pickMethod(methodName,argClasses);
if (method != null) return ownerMetaClass.invokeMethod(owner,methodName,originalArguments);
}
if (method == null && resolveStrategy != Closure.TO_SELF) {
MissingMethodException last=null;
if (delegate != closure && (delegate instanceof GroovyObject)) {
try {
return invokeMethodOnGroovyObject(methodName,originalArguments,delegate);
}
 catch (MissingMethodException mme) {
if (last == null) last=mme;
}
}
if (isClosureNotOwner && (owner instanceof GroovyObject)) {
try {
return invokeMethodOnGroovyObject(methodName,originalArguments,owner);
}
 catch (MissingMethodException mme) {
last=mme;
}
}
if (last != null) return invokeMissingMethod(object,methodName,originalArguments,last);
}
break;
default :
if (method == null && owner != closure) {
MetaClass ownerMetaClass=lookupObjectMetaClass(owner);
method=ownerMetaClass.pickMethod(methodName,argClasses);
if (method != null) return ownerMetaClass.invokeMethod(owner,methodName,originalArguments);
}
if (method == null && delegate != closure && delegate != null) {
MetaClass delegateMetaClass=lookupObjectMetaClass(delegate);
method=delegateMetaClass.pickMethod(methodName,argClasses);
if (method != null) return delegateMetaClass.invokeMethod(delegate,methodName,originalArguments);
}
if (method == null && resolveStrategy != Closure.TO_SELF) {
MissingMethodException last=null;
if (isClosureNotOwner && (owner instanceof GroovyObject)) {
try {
return invokeMethodOnGroovyObject(methodName,originalArguments,owner);
}
 catch (MissingMethodException mme) {
if (last == null) last=mme;
}
}
if (delegate != closure && (delegate instanceof GroovyObject)) {
try {
return invokeMethodOnGroovyObject(methodName,originalArguments,delegate);
}
 catch (MissingMethodException mme) {
last=mme;
}
}
if (last != null) return invokeMissingMethod(object,methodName,originalArguments,last);
}
}
}
if (method != null) {
return MetaClassHelper.doMethodInvoke(object,method,arguments);
}
 else {
Object value=null;
try {
value=this.getProperty(object,methodName);
}
 catch (MissingPropertyException mpe) {
}
if (value instanceof Closure) {
Closure closure=(Closure)value;
MetaClass delegateMetaClass=closure.getMetaClass();
return delegateMetaClass.invokeMethod(closure.getClass(),closure,CLOSURE_DO_CALL_METHOD,originalArguments,false,fromInsideClass);
}
return invokeMissingMethod(object,methodName,originalArguments);
}
}
