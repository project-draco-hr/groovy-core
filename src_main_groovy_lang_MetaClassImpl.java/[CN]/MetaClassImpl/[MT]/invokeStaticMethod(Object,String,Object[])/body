{
  checkInitalised();
  if (log.isLoggable(Level.FINER)) {
    MetaClassHelper.logMethodCall(object,methodName,arguments);
  }
  Class sender=object.getClass();
  if (object instanceof Class)   sender=(Class)object;
  if (sender != theClass) {
    MetaClass mc=registry.getMetaClass(sender);
    return mc.invokeStaticMethod(sender,methodName,arguments);
  }
  if (sender == Class.class) {
    return invokeMethod(object,methodName,arguments);
  }
  if (arguments == null)   arguments=EMPTY_ARGUMENTS;
  Class[] argClasses=MetaClassHelper.convertToTypeArray(arguments);
  Object[] originalArguments=(Object[])arguments.clone();
  unwrap(arguments);
  MethodKey methodKey=new DefaultMethodKey(sender,methodName,argClasses,false);
  MetaMethod method=(MetaMethod)staticMethodCache.get(methodKey);
  if (method == null) {
    method=pickStaticMethod(sender,methodName,argClasses);
    cacheStaticMethod(methodKey.createCopy(),method);
  }
  if (method != null) {
    return MetaClassHelper.doMethodInvoke(object,method,arguments);
  }
  try {
    Object prop=getProperty(theClass,theClass,methodName,false,false);
    if (prop instanceof Closure) {
      Closure closure=(Closure)prop;
      MetaClass delegateMetaClass=closure.getMetaClass();
      return delegateMetaClass.invokeMethod(closure.getClass(),closure,"doCall",originalArguments,false,false);
    }
  }
 catch (  MissingPropertyException mpe) {
  }
  Class superClass=sender.getSuperclass();
  if (superClass != Object.class && superClass != null) {
    return invokeStaticMethod(sender.getSuperclass(),methodName,arguments);
  }
  throw new MissingMethodException(methodName,sender,arguments,true);
}
