{
  if (theClass.isInterface()) {
    LinkedList superClasses=new LinkedList();
    superClasses.add(ReflectionCache.OBJECT_CLASS);
    addMethods(Object.class);
    Set interfaces=theCachedClass.getInterfaces();
    inheritInterfaceMethods(interfaces);
    Map theClassIndex=classMethodIndex.getNotNull(theClass);
    Map objectIndex=classMethodIndex.getNotNull(Object.class);
    copyNonPrivateMethods(objectIndex,theClassIndex);
    classMethodIndexForSuper=classMethodIndex;
    superClasses.addAll(interfaces);
    for (Iterator iter=superClasses.iterator(); iter.hasNext(); ) {
      CachedClass c=(CachedClass)iter.next();
      classMethodIndex.put(c.cachedClass,theClassIndex);
      if (c != ReflectionCache.OBJECT_CLASS)       addMethods(c.cachedClass);
    }
  }
 else {
    LinkedList superClasses=getSuperClasses();
    for (Iterator iter=superClasses.iterator(); iter.hasNext(); ) {
      CachedClass c=(CachedClass)iter.next();
      addMethods(c.cachedClass);
    }
    Set interfaces=theCachedClass.getInterfaces();
    inheritMethods(superClasses);
    inheritInterfaceMethods(interfaces);
    classMethodIndexForSuper=classMethodIndex.copy();
    connectMultimethods(superClasses);
    populateInterfaces(interfaces);
    removeMultimethodsOverloadedWithPrivateMethods();
  }
  replaceWithMOPCalls();
}
