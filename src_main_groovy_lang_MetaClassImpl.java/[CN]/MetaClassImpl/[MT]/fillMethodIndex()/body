{
  if (theClass.isInterface()) {
    LinkedList superClasses=new LinkedList();
    superClasses.add(ReflectionCache.OBJECT_CLASS);
    addMethods(ReflectionCache.OBJECT_CLASS);
    Set interfaces=theCachedClass.getInterfaces();
    inheritInterfaceMethods(interfaces);
    SingleKeyHashMap theClassIndex=classMethodIndex.getNotNull(theCachedClass);
    SingleKeyHashMap objectIndex=classMethodIndex.getNotNull(ReflectionCache.OBJECT_CLASS);
    copyNonPrivateMethods(objectIndex,theClassIndex);
    classMethodIndexForSuper=classMethodIndex;
    superClasses.addAll(interfaces);
    for (Iterator iter=superClasses.iterator(); iter.hasNext(); ) {
      CachedClass c=(CachedClass)iter.next();
      classMethodIndex.put(c,theClassIndex);
      if (c != ReflectionCache.OBJECT_CLASS)       addMethods(c);
    }
  }
 else {
    LinkedList superClasses=getSuperClasses();
    addInterfaceMethods();
    for (Iterator iter=superClasses.iterator(); iter.hasNext(); ) {
      CachedClass c=(CachedClass)iter.next();
      addMethods(c);
    }
    Set interfaces=theCachedClass.getInterfaces();
    inheritMethods(superClasses);
    inheritInterfaceMethods(interfaces);
    classMethodIndexForSuper=classMethodIndex.copy();
    connectMultimethods(superClasses);
    populateInterfaces(interfaces);
    removeMultimethodsOverloadedWithPrivateMethods();
  }
  replaceWithMOPCalls();
}
