{
  ArrayList mopMethodsList=new ArrayList();
  if (theClass.isInterface()) {
    LinkedList superClasses=new LinkedList();
    superClasses.add(ReflectionCache.OBJECT_CLASS);
    addMethods(ReflectionCache.OBJECT_CLASS,mopMethodsList);
    Set interfaces=theCachedClass.getInterfaces();
    inheritInterfaceMethods(interfaces);
    SingleKeyHashMap theClassIndex=classMethodIndex.getNotNull(theCachedClass);
    SingleKeyHashMap objectIndex=classMethodIndex.getNotNull(ReflectionCache.OBJECT_CLASS);
    copyNonPrivateMethods(objectIndex,theClassIndex);
    classMethodIndexForSuper=classMethodIndex;
    superClasses.addAll(interfaces);
    for (Iterator iter=superClasses.iterator(); iter.hasNext(); ) {
      CachedClass c=(CachedClass)iter.next();
      classMethodIndex.put(c,theClassIndex);
      if (c != ReflectionCache.OBJECT_CLASS)       addMethods(c,null);
    }
  }
 else {
    LinkedList superClasses=getSuperClasses();
    addInterfaceMethods();
    for (Iterator iter=superClasses.iterator(); iter.hasNext(); ) {
      CachedClass c=(CachedClass)iter.next();
      addMethods(c,mopMethodsList);
    }
    Set interfaces=theCachedClass.getInterfaces();
    inheritMethods(superClasses);
    inheritInterfaceMethods(interfaces);
    classMethodIndexForSuper=classMethodIndex.copy();
    connectMultimethods(superClasses);
    populateInterfaces(interfaces);
    removeMultimethodsOverloadedWithPrivateMethods();
    MetaMethod mopMethods[]=(MetaMethod[])mopMethodsList.toArray(new MetaMethod[mopMethodsList.size()]);
    final MetaMethodComparator metaMethodComparator=new MetaMethodComparator();
    Arrays.sort(mopMethods,metaMethodComparator);
    replaceWithMOPCalls(mopMethods);
  }
}
