{
  MethodVisitor mv;
  final int pc=method.getParameterTypes().length;
  if (pc <= 4) {
    StringBuilder pdescb=new StringBuilder();
    for (int i=0; i != pc; ++i)     pdescb.append("Ljava/lang/Object;");
    String pdesc=pdescb.toString();
    mv=cw.visitMethod(Opcodes.ACC_PUBLIC,"invoke","(Ljava/lang/Object;" + pdesc + ")Ljava/lang/Object;",null,EXCEPTIONS);
    mv.visitCode();
    Class callClass=method.getDeclaringClass();
    boolean useInterface=callClass.isInterface();
    String type=BytecodeHelper.getClassInternalName(callClass.getName());
    String descriptor=BytecodeHelper.getMethodDescriptor(method.getReturnType(),method.getParameterTypes());
    if (Modifier.isStatic(method.getModifiers())) {
      MethodHandleFactory.genLoadParametersDirect(2,mv,method);
      mv.visitMethodInsn(Opcodes.INVOKESTATIC,type,method.getName(),descriptor);
    }
 else {
      mv.visitVarInsn(Opcodes.ALOAD,1);
      BytecodeHelper.doCast(mv,callClass);
      MethodHandleFactory.genLoadParametersDirect(2,mv,method);
      mv.visitMethodInsn((useInterface) ? Opcodes.INVOKEINTERFACE : Opcodes.INVOKEVIRTUAL,type,method.getName(),descriptor);
    }
    BytecodeHelper.box(mv,method.getReturnType());
    if (method.getReturnType() == void.class) {
      mv.visitInsn(Opcodes.ACONST_NULL);
    }
    mv.visitInsn(Opcodes.ARETURN);
    mv.visitMaxs(0,0);
    mv.visitEnd();
  }
}
