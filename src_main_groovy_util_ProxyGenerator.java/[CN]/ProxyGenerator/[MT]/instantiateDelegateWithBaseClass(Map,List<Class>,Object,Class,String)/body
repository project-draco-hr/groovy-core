{
  Map map=new HashMap();
  if (closureMap != null) {
    map=closureMap;
  }
  List<String> selectedMethods=new ArrayList<String>();
  List<Class> interfacesToImplement;
  if (interfaces == null) {
    interfacesToImplement=new ArrayList<Class>();
  }
 else {
    interfacesToImplement=interfaces;
  }
  StringBuffer buffer=new StringBuffer();
  buffer.append("import org.codehaus.groovy.runtime.InvokerHelper\nclass ").append(name);
  if (baseClass != null) {
    buffer.append(" extends ").append(baseClass.getName());
  }
  for (int i=0; i < interfacesToImplement.size(); i++) {
    Class thisInterface=interfacesToImplement.get(i);
    if (i == 0) {
      buffer.append(" implements ");
    }
 else {
      buffer.append(", ");
    }
    buffer.append(thisInterface.getName());
  }
  buffer.append(" {\n").append("    private delegate\n").append("    private closureMap\n    ");
  buffer.append(name).append("(map, delegate) {\n");
  buffer.append("        this.closureMap = map\n");
  buffer.append("        this.delegate = delegate\n");
  buffer.append("    }\n");
  List<Method> interfaceMethods=new ArrayList<Method>();
  for (  Class thisInterface : interfacesToImplement) {
    getInheritedMethods(thisInterface,interfaceMethods);
  }
  for (  Method method : interfaceMethods) {
    if (!containsEquivalentMethod(objectMethods,method) && !containsEquivalentMethod(groovyObjectMethods,method)) {
      selectedMethods.add(method.getName());
      addWrappedCall(buffer,method,map);
    }
  }
  List<Method> additionalMethods=getInheritedMethods(delegate.getClass(),new ArrayList<Method>());
  for (  Method method : additionalMethods) {
    if (method.getName().indexOf('$') != -1)     continue;
    if (!containsEquivalentMethod(interfaceMethods,method) && !containsEquivalentMethod(objectMethods,method) && !containsEquivalentMethod(groovyObjectMethods,method)) {
      selectedMethods.add(method.getName());
      addWrappedCall(buffer,method,map);
    }
  }
  for (  Object o : map.keySet()) {
    String methodName=(String)o;
    if (selectedMethods.contains(methodName))     continue;
    addNewMapCall(buffer,methodName);
  }
  buffer.append("}\n").append("new ").append(name);
  buffer.append("(map, delegate)");
  Binding binding=new Binding();
  binding.setVariable("map",map);
  binding.setVariable("delegate",delegate);
  ClassLoader cl=override != null ? override : delegate.getClass().getClassLoader();
  GroovyShell shell=new GroovyShell(cl,binding);
  if (debug)   System.out.println("proxy source:\n------------------\n" + buffer.toString() + "\n------------------");
  try {
    return (GroovyObject)shell.evaluate(buffer.toString());
  }
 catch (  MultipleCompilationErrorsException err) {
    throw new GroovyRuntimeException("Error creating proxy: " + err.getMessage());
  }
}
