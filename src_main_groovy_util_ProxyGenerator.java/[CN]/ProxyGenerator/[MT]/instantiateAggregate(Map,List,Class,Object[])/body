{
  Map map=new HashMap();
  if (closureMap != null) {
    map=closureMap;
  }
  List interfacesToImplement=new ArrayList();
  if (interfaces != null) {
    interfacesToImplement=interfaces;
  }
  Class baseClass=GroovyObjectSupport.class;
  if (clazz != null) {
    baseClass=clazz;
  }
  boolean hasArgs=constructorArgs != null && constructorArgs.length > 0;
  String name=shortName(baseClass.getName()) + "_groovyProxy";
  StringBuffer buffer=new StringBuffer();
  buffer.append("class ").append(name);
  if (clazz != null) {
    buffer.append(" extends ").append(baseClass.getName());
  }
  for (int i=0; i < interfacesToImplement.size(); i++) {
    Class thisInterface=(Class)interfacesToImplement.get(i);
    if (i == 0) {
      buffer.append(" implements ");
    }
 else {
      buffer.append(", ");
    }
    buffer.append(thisInterface.getName());
  }
  buffer.append(" {\n").append("    private closureMap\n    ");
  buffer.append(name).append("(map");
  if (hasArgs) {
    buffer.append(", args");
  }
  buffer.append(") {\n");
  buffer.append("        super(");
  if (hasArgs) {
    buffer.append("*args");
  }
  buffer.append(")\n");
  buffer.append("        this.closureMap = map\n");
  buffer.append("    }\n");
  Map<String,Method> selectedMethods=new HashMap<String,Method>();
  List<Method> publicAndProtectedMethods=getInheritedMethods(baseClass,new ArrayList<Method>());
  boolean closureIndicator=map.containsKey("*");
  for (  Method method : publicAndProtectedMethods) {
    if (method.getName().indexOf('$') != -1 || Modifier.isFinal(method.getModifiers()) || containsEquivalentMethod(objectMethods,method) || containsEquivalentMethod(selectedMethods.values(),method))     continue;
    if (map.containsKey(method.getName()) || closureIndicator) {
      selectedMethods.put(method.getName(),method);
      addOverridingMapCall(buffer,method,closureIndicator);
    }
  }
  ArrayList interfaceMethods=new ArrayList();
  for (int i=0; i < interfacesToImplement.size(); i++) {
    Class thisInterface=(Class)interfacesToImplement.get(i);
    getInheritedMethods(thisInterface,interfaceMethods);
  }
  for (int i=0; i < interfaceMethods.size(); i++) {
    Method method=(Method)interfaceMethods.get(i);
    if (!containsEquivalentMethod(publicAndProtectedMethods,method)) {
      selectedMethods.put(method.getName(),method);
      addMapOrDummyCall(map,buffer,method);
    }
  }
  for (Iterator iterator=map.keySet().iterator(); iterator.hasNext(); ) {
    String methodName=(String)iterator.next();
    if (methodName.indexOf('$') != -1 || methodName.indexOf('*') != -1)     continue;
    if (selectedMethods.keySet().contains(methodName))     continue;
    addNewMapCall(buffer,methodName);
  }
  buffer.append("}\n").append("new ").append(name);
  buffer.append("(map");
  if (hasArgs) {
    buffer.append(", constructorArgs");
  }
  buffer.append(")");
  Binding binding=new Binding();
  binding.setVariable("map",map);
  binding.setVariable("constructorArgs",constructorArgs);
  ClassLoader cl=override != null ? override : baseClass.getClassLoader();
  if (clazz == null && interfacesToImplement.size() > 0) {
    Class c=(Class)interfacesToImplement.get(0);
    cl=c.getClassLoader();
  }
  GroovyShell shell=new GroovyShell(cl,binding);
  if (debug)   System.out.println("proxy source:\n------------------\n" + buffer.toString() + "\n------------------");
  try {
    return shell.evaluate(buffer.toString());
  }
 catch (  MultipleCompilationErrorsException err) {
    throw new GroovyRuntimeException("Error creating proxy: " + err.getMessage());
  }
}
