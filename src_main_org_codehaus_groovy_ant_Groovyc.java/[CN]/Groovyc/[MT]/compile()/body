{
  try {
    if (compileList.length > 0) {
      log("Compiling " + compileList.length + " source file"+ (compileList.length == 1 ? "" : "s")+ (destDir != null ? " to " + destDir : ""));
      if (listFiles) {
        for (        File srcFile : compileList) {
          log(srcFile.getAbsolutePath());
        }
      }
      Path classpath=getClasspath() != null ? getClasspath() : new Path(getProject());
      List<String> jointOptions=new ArrayList<String>();
      if (jointCompilation) {
        for (Iterator i=javac.getRuntimeConfigurableWrapper().getAttributeMap().entrySet().iterator(); i.hasNext(); ) {
          final Map.Entry e=(Map.Entry)i.next();
          final String key=e.getKey().toString();
          final String value=getProject().replaceProperties(e.getValue().toString());
          if (key.contains("debug")) {
            String level="";
            if (javac.getDebugLevel() != null) {
              level=":" + javac.getDebugLevel();
            }
            jointOptions.add("-Fg" + level);
          }
 else           if (key.contains("debugLevel")) {
          }
 else           if ((key.contains("nowarn")) || (key.contains("verbose")) || (key.contains("deprecation"))) {
            if ("on".equalsIgnoreCase(value) || "true".equalsIgnoreCase(value) || "yes".equalsIgnoreCase("value"))             jointOptions.add("-F" + key);
          }
 else           if (key.contains("classpath")) {
            classpath.add(javac.getClasspath());
          }
 else           if ((key.contains("depend")) || (key.contains("extdirs")) || (key.contains("encoding"))|| (key.contains("source"))|| (key.contains("target"))|| (key.contains("verbose"))) {
            jointOptions.add("-J" + key + "="+ value);
          }
 else {
            log("The option " + key + " cannot be set on the contained <javac> element. The option will be ignored",Project.MSG_WARN);
          }
        }
      }
      String separator=System.getProperty("file.separator");
      List<String> commandLineList=new ArrayList<String>();
      if (fork) {
        String javaHome;
        if (forkJDK != null) {
          javaHome=forkJDK.getPath();
        }
 else {
          javaHome=System.getProperty("java.home");
        }
        if (includeAntRuntime) {
          classpath.addExisting((new Path(getProject())).concatSystemClasspath("last"));
        }
        if (includeJavaRuntime) {
          classpath.addJavaRuntime();
        }
        commandLineList.add(javaHome + separator + "bin"+ separator+ "java");
        commandLineList.add("-classpath");
        commandLineList.add(classpath.toString());
        if ((memoryInitialSize != null) && !memoryInitialSize.equals("")) {
          commandLineList.add("-Xms" + memoryInitialSize);
        }
        if ((memoryMaximumSize != null) && !memoryMaximumSize.equals("")) {
          commandLineList.add("-Xmx" + memoryMaximumSize);
        }
        commandLineList.add("org.codehaus.groovy.tools.FileSystemCompiler");
      }
      commandLineList.add("--classpath");
      commandLineList.add(classpath.toString());
      if (jointCompilation) {
        commandLineList.add("-j");
        commandLineList.addAll(jointOptions);
      }
      commandLineList.add("-d");
      commandLineList.add(destDir.getPath());
      if (encoding != null) {
        commandLineList.add("--encoding");
        commandLineList.add(encoding);
      }
      if (stacktrace) {
        commandLineList.add("-e");
      }
      int count=0;
      if (fork) {
        for (        File srcFile : compileList) {
          count+=srcFile.getPath().length();
        }
        for (        Object commandLineArg : commandLineList) {
          count+=commandLineArg.toString().length();
        }
        count+=compileList.length;
        count+=commandLineList.size();
      }
      if (fork && (count > 32767)) {
        try {
          File tempFile=File.createTempFile("groovyc-files-",".txt");
          temporaryFiles.add(tempFile);
          PrintWriter pw=new PrintWriter(new FileWriter(tempFile));
          for (          File srcFile : compileList) {
            pw.println(srcFile.getPath());
          }
          pw.close();
          commandLineList.add("@" + tempFile.getPath());
        }
 catch (        IOException e) {
          log("Error creating file list",e,Project.MSG_ERR);
        }
      }
 else {
        for (        File srcFile : compileList) {
          commandLineList.add(srcFile.getPath());
        }
      }
      final String[] commandLine=new String[commandLineList.size()];
      for (int i=0; i < commandLine.length; ++i) {
        commandLine[i]=commandLineList.get(i);
      }
      log("Compilation arguments:",Project.MSG_VERBOSE);
      log(DefaultGroovyMethods.join(commandLine,"\n"),Project.MSG_VERBOSE);
      if (fork) {
        final Execute executor=new Execute();
        executor.setAntRun(getProject());
        executor.setWorkingDirectory(getProject().getBaseDir());
        executor.setCommandline(commandLine);
        try {
          executor.execute();
        }
 catch (        final IOException ioe) {
          throw new BuildException("Error running forked groovyc.",ioe);
        }
        final int returnCode=executor.getExitValue();
        if (returnCode != 0) {
          if (failOnError) {
            throw new BuildException("Forked groovyc returned error code: " + returnCode);
          }
 else {
            log("Forked groovyc returned error code: " + returnCode,Project.MSG_ERR);
          }
        }
      }
 else {
        try {
          Options options=FileSystemCompiler.createCompilationOptions();
          PosixParser cliParser=new PosixParser();
          CommandLine cli;
          cli=cliParser.parse(options,commandLine);
          configuration=FileSystemCompiler.generateCompilerConfigurationFromOptions(cli);
          String[] filenames=FileSystemCompiler.generateFileNamesFromOptions(cli);
          boolean fileNameErrors=filenames == null;
          fileNameErrors=fileNameErrors && !FileSystemCompiler.validateFiles(filenames);
          if (!fileNameErrors) {
            FileSystemCompiler.doCompilation(configuration,makeCompileUnit(),filenames);
          }
        }
 catch (        Exception re) {
          Throwable t=re;
          if ((re.getClass() == RuntimeException.class) && (re.getCause() != null)) {
            t=re.getCause();
          }
          StringWriter writer=new StringWriter();
          new ErrorReporter(t,false).write(new PrintWriter(writer));
          String message=writer.toString();
          if (failOnError) {
            log(message,Project.MSG_INFO);
            throw new BuildException("Compilation Failed",t,getLocation());
          }
 else {
            log(message,Project.MSG_ERR);
          }
        }
      }
    }
  }
  finally {
    for (    File temporaryFile : temporaryFiles) {
      try {
        FileSystemCompiler.deleteRecursive(temporaryFile);
      }
 catch (      Throwable t) {
        System.err.println("error: could not delete temp files - " + temporaryFile.getPath());
      }
    }
  }
}
