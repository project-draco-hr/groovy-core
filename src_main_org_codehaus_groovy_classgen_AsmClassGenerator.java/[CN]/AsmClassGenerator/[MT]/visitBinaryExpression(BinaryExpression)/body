{
  onLineNumber(expression,"visitBinaryExpression: \"" + expression.getOperation().getText() + "\" ");
switch (expression.getOperation().getType()) {
case Types.EQUAL:
    evaluateEqual(expression,false);
  break;
case Types.COMPARE_IDENTICAL:
evaluateBinaryExpression(compareIdenticalMethod,expression);
break;
case Types.COMPARE_EQUAL:
evaluateBinaryExpression(compareEqualMethod,expression);
break;
case Types.COMPARE_NOT_EQUAL:
evaluateBinaryExpression(compareNotEqualMethod,expression);
break;
case Types.COMPARE_TO:
evaluateCompareTo(expression);
break;
case Types.COMPARE_GREATER_THAN:
evaluateBinaryExpression(compareGreaterThanMethod,expression);
break;
case Types.COMPARE_GREATER_THAN_EQUAL:
evaluateBinaryExpression(compareGreaterThanEqualMethod,expression);
break;
case Types.COMPARE_LESS_THAN:
evaluateBinaryExpression(compareLessThanMethod,expression);
break;
case Types.COMPARE_LESS_THAN_EQUAL:
evaluateBinaryExpression(compareLessThanEqualMethod,expression);
break;
case Types.LOGICAL_AND:
evaluateLogicalAndExpression(expression);
break;
case Types.LOGICAL_OR:
evaluateLogicalOrExpression(expression);
break;
case Types.BITWISE_AND:
evaluateBinaryExpression("and",expression);
break;
case Types.BITWISE_AND_EQUAL:
evaluateBinaryExpressionWithAssignment("and",expression);
break;
case Types.BITWISE_OR:
evaluateBinaryExpression("or",expression);
break;
case Types.BITWISE_OR_EQUAL:
evaluateBinaryExpressionWithAssignment("or",expression);
break;
case Types.BITWISE_XOR:
evaluateBinaryExpression("xor",expression);
break;
case Types.BITWISE_XOR_EQUAL:
evaluateBinaryExpressionWithAssignment("xor",expression);
break;
case Types.PLUS:
evaluateBinaryExpression("plus",expression);
break;
case Types.PLUS_EQUAL:
evaluateBinaryExpressionWithAssignment("plus",expression);
break;
case Types.MINUS:
evaluateBinaryExpression("minus",expression);
break;
case Types.MINUS_EQUAL:
evaluateBinaryExpressionWithAssignment("minus",expression);
break;
case Types.MULTIPLY:
evaluateBinaryExpression("multiply",expression);
break;
case Types.MULTIPLY_EQUAL:
evaluateBinaryExpressionWithAssignment("multiply",expression);
break;
case Types.DIVIDE:
evaluateBinaryExpression("div",expression);
break;
case Types.DIVIDE_EQUAL:
evaluateBinaryExpressionWithAssignment("div",expression);
break;
case Types.INTDIV:
evaluateBinaryExpression("intdiv",expression);
break;
case Types.INTDIV_EQUAL:
evaluateBinaryExpressionWithAssignment("intdiv",expression);
break;
case Types.MOD:
evaluateBinaryExpression("mod",expression);
break;
case Types.MOD_EQUAL:
evaluateBinaryExpressionWithAssignment("mod",expression);
break;
case Types.POWER:
evaluateBinaryExpression("power",expression);
break;
case Types.POWER_EQUAL:
evaluateBinaryExpressionWithAssignment("power",expression);
break;
case Types.LEFT_SHIFT:
evaluateBinaryExpression("leftShift",expression);
break;
case Types.LEFT_SHIFT_EQUAL:
evaluateBinaryExpressionWithAssignment("leftShift",expression);
break;
case Types.RIGHT_SHIFT:
evaluateBinaryExpression("rightShift",expression);
break;
case Types.RIGHT_SHIFT_EQUAL:
evaluateBinaryExpressionWithAssignment("rightShift",expression);
break;
case Types.RIGHT_SHIFT_UNSIGNED:
evaluateBinaryExpression("rightShiftUnsigned",expression);
break;
case Types.RIGHT_SHIFT_UNSIGNED_EQUAL:
evaluateBinaryExpressionWithAssignment("rightShiftUnsigned",expression);
break;
case Types.KEYWORD_INSTANCEOF:
evaluateInstanceof(expression);
break;
case Types.FIND_REGEX:
evaluateBinaryExpression(findRegexMethod,expression);
break;
case Types.MATCH_REGEX:
evaluateBinaryExpression(matchRegexMethod,expression);
break;
case Types.LEFT_SQUARE_BRACKET:
if (leftHandExpression) {
throwException("Should not be called here. Possible reason: postfix operation on array.");
}
 else {
evaluateBinaryExpression("getAt",expression);
}
break;
case Types.KEYWORD_IN:
evaluateBinaryExpression(isCaseMethod,expression);
break;
default :
throwException("Operation: " + expression.getOperation() + " not supported");
}
}
