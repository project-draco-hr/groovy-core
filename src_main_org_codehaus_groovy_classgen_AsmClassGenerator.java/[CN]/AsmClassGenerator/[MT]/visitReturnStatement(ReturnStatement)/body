{
  onLineNumber(statement,"visitReturnStatement");
  visitStatement(statement);
  ClassNode returnType;
  if (methodNode != null) {
    returnType=methodNode.getReturnType();
  }
 else   if (constructorNode != null) {
    returnType=constructorNode.getReturnType();
  }
 else {
    throw new GroovyBugError("I spotted a return that is neither in a method nor in a constructor... I can not handle that");
  }
  if (returnType == ClassHelper.VOID_TYPE) {
    if (!(statement == ReturnStatement.RETURN_NULL_OR_VOID)) {
      throwException("Cannot use return statement with an expression on a method that returns void");
    }
    compileStack.applyFinallyBlocks();
    cv.visitInsn(RETURN);
    outputReturn=true;
    return;
  }
  Expression expression=statement.getExpression();
  evaluateExpression(expression);
  if (returnType == ClassHelper.OBJECT_TYPE && expression.getType() != null && expression.getType() == ClassHelper.VOID_TYPE) {
    cv.visitInsn(ACONST_NULL);
  }
 else {
    doConvertAndCast(returnType,expression,false,true,false);
  }
  if (compileStack.hasFinallyBlocks()) {
    int returnValueIdx=compileStack.defineTemporaryVariable("returnValue",ClassHelper.OBJECT_TYPE,true);
    compileStack.applyFinallyBlocks();
    helper.load(ClassHelper.OBJECT_TYPE,returnValueIdx);
  }
  helper.unbox(returnType);
  helper.doReturn(returnType);
  outputReturn=true;
}
