{
  ClassNode owner=getOutermostClass();
  boolean parentIsInnerClass=owner instanceof InnerClassNode;
  String outerClassName=owner.getType().getName();
  String name=outerClassName + "$" + context.getNextClosureInnerName(owner,classNode,methodNode);
  boolean staticMethodOrInStaticClass=isStaticMethod() || classNode.isStaticClass();
  if (staticMethodOrInStaticClass) {
    outerClassName="java.lang.Class";
  }
  Parameter[] parameters=expression.getParameters();
  if (parameters == null || parameters.length == 0) {
    parameters=new Parameter[]{new Parameter(Type.OBJECT_TYPE,"it",ConstantExpression.NULL)};
  }
  Parameter[] localVariableParams=getClosureSharedVariables(expression);
  InnerClassNode answer=new InnerClassNode(owner,Type.makeType(name),0,Type.CLOSURE_TYPE);
  answer.setEnclosingMethod(this.methodNode);
  answer.setSynthetic(true);
  if (staticMethodOrInStaticClass) {
    answer.setStaticClass(true);
  }
  if (isInScriptBody()) {
    answer.setScriptBody(true);
  }
  MethodNode method=answer.addMethod("doCall",ACC_PUBLIC,Type.OBJECT_TYPE,parameters,expression.getCode());
  method.setLineNumber(expression.getLineNumber());
  method.setColumnNumber(expression.getColumnNumber());
  VariableScope varScope=expression.getVariableScope();
  if (varScope == null) {
    throw new RuntimeException("Must have a VariableScope by now! for expression: " + expression + " class: "+ name);
  }
 else {
    method.setVariableScope(varScope);
  }
  if (parameters.length > 1 || (parameters.length == 1 && parameters[0].getType() != null && parameters[0].getType() != Type.OBJECT_TYPE)) {
    answer.addMethod("call",ACC_PUBLIC,Type.OBJECT_TYPE,parameters,new ReturnStatement(new MethodCallExpression(VariableExpression.THIS_EXPRESSION,"doCall",new ArgumentListExpression(parameters))));
  }
  FieldNode ownerField=answer.addField("owner",ACC_PRIVATE,Type.makeType(outerClassName),null);
  BlockStatement block=new BlockStatement();
  block.addStatement(new ExpressionStatement(new MethodCallExpression(new VariableExpression("super"),"<init>",new VariableExpression("_outerInstance"))));
  block.addStatement(new ExpressionStatement(new BinaryExpression(new FieldExpression(ownerField),Token.newSymbol(Types.EQUAL,-1,-1),new VariableExpression("_outerInstance"))));
  for (int i=0; i < localVariableParams.length; i++) {
    Parameter param=localVariableParams[i];
    String paramName=param.getName();
    boolean holder=mutableVars.contains(paramName);
    Expression initialValue=null;
    Type type=param.getType();
    FieldNode paramField=null;
    if (holder) {
      initialValue=new VariableExpression(paramName);
      type=type.makeReference();
      param.setType(type);
      paramField=answer.addField(paramName,ACC_PRIVATE,type,initialValue);
      paramField.setHolder(true);
      Type realType=type.getRealType();
      String methodName=Verifier.capitalize(paramName);
      Expression fieldExp=new FieldExpression(paramField);
      answer.addMethod("get" + methodName,ACC_PUBLIC,realType,Parameter.EMPTY_ARRAY,new ReturnStatement(fieldExp));
    }
 else {
      PropertyNode propertyNode=answer.addProperty(paramName,ACC_PUBLIC,type,initialValue,null,null);
      paramField=propertyNode.getField();
      block.addStatement(new ExpressionStatement(new BinaryExpression(new FieldExpression(paramField),Token.newSymbol(Types.EQUAL,-1,-1),new VariableExpression(paramName))));
    }
  }
  Parameter[] params=new Parameter[2 + localVariableParams.length];
  params[0]=new Parameter(Type.makeType(outerClassName),"_outerInstance");
  params[1]=new Parameter(Type.OBJECT_TYPE,"_delegate");
  System.arraycopy(localVariableParams,0,params,2,localVariableParams.length);
  answer.addConstructor(ACC_PUBLIC,params,block);
  return answer;
}
