{
  onLineNumber(call,"visitMethodCallExpression: \"" + call.getMethod() + "\":");
  Expression arguments=call.getArguments();
  String methodName=call.getMethodAsString();
  boolean isSuperMethodCall=MethodCallExpression.isSuperMethodCall(call);
  boolean isThisExpression=isThisExpression(call.getObjectExpression());
  if (methodName != null && isThisExpression && isFieldOrVariable(methodName) && !classNode.hasPossibleMethod(methodName,arguments)) {
    visitVariableExpression(new VariableExpression(methodName));
    arguments.visit(this);
    invokeClosureMethod.call(cv);
  }
 else {
    MethodCallerMultiAdapter adapter=invokeMethod;
    if (isThisExpression)     adapter=invokeMethodOnCurrent;
    if (isSuperMethodCall)     adapter=invokeMethodOnSuper;
    if (isStaticMethod() && isThisExpression)     adapter=invokeStaticMethod;
    if (isSuperMethodCall) {
      MethodNode superMethodNode=findSuperMethod(call);
      cv.visitVarInsn(ALOAD,0);
      loadArguments(superMethodNode.getParameters(),arguments);
      String descriptor=BytecodeHelper.getMethodDescriptor(superMethodNode.getReturnType(),superMethodNode.getParameters());
      cv.visitMethodInsn(INVOKESPECIAL,BytecodeHelper.getClassInternalName(superMethodNode.getDeclaringClass()),methodName,descriptor);
      helper.box(superMethodNode.getReturnType());
    }
 else {
      makeInvokeMethodCall(call,adapter);
    }
  }
}
