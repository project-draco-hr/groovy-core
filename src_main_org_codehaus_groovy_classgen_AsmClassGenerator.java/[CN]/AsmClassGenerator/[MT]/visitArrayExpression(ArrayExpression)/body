{
  Type type=expression.getType().getComponentType();
  String typeName=BytecodeHelper.getClassInternalName(type);
  Expression sizeExpression=expression.getSizeExpression();
  int size=0;
  if (sizeExpression != null) {
    visitAndAutoboxBoolean(sizeExpression);
    asIntMethod.call(cv);
  }
 else {
    size=expression.getExpressions().size();
    helper.pushConstant(size);
  }
  int storeIns=AASTORE;
  if (type.isPrimitiveType()) {
    int primType=0;
    if (type == Type.boolean_TYPE) {
      primType=T_BOOLEAN;
      storeIns=BASTORE;
    }
 else     if (type == Type.char_TYPE) {
      primType=T_CHAR;
      storeIns=CASTORE;
    }
 else     if (type == Type.float_TYPE) {
      primType=T_FLOAT;
      storeIns=FASTORE;
    }
 else     if (type == Type.double_TYPE) {
      primType=T_DOUBLE;
      storeIns=DASTORE;
    }
 else     if (type == Type.byte_TYPE) {
      primType=T_BYTE;
      storeIns=BASTORE;
    }
 else     if (type == Type.short_TYPE) {
      primType=T_SHORT;
      storeIns=SASTORE;
    }
 else     if (type == Type.int_TYPE) {
      primType=T_INT;
      storeIns=IASTORE;
    }
 else     if (type == Type.long_TYPE) {
      primType=T_LONG;
      storeIns=LASTORE;
    }
    cv.visitIntInsn(NEWARRAY,primType);
  }
 else {
    cv.visitTypeInsn(ANEWARRAY,typeName);
  }
  for (int i=0; i < size; i++) {
    cv.visitInsn(DUP);
    helper.pushConstant(i);
    Expression elementExpression=expression.getExpression(i);
    if (elementExpression == null) {
      ConstantExpression.NULL.visit(this);
    }
 else {
      if (!type.equals(elementExpression.getType())) {
        visitCastExpression(new CastExpression(type,elementExpression,true));
      }
 else {
        visitAndAutoboxBoolean(elementExpression);
      }
    }
    cv.visitInsn(storeIns);
  }
  if (type.isPrimitiveType()) {
    int par=defineVariable("par",Type.OBJECT_TYPE).getIndex();
    cv.visitVarInsn(ASTORE,par);
    cv.visitVarInsn(ALOAD,par);
  }
}
