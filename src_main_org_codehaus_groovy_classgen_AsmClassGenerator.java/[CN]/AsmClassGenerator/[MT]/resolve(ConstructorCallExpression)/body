{
  if (call.isResolveFailed()) {
    return;
  }
 else   if (call.isTypeResolved()) {
    return;
  }
  String declaredType=call.getTypeToSet();
  if (declaredType.equals(classNode.getName())) {
    call.setResolveFailed(true);
    call.setFailure("cannot resolve on the current class itself. ");
    return;
  }
 else {
    call.setType(declaredType);
    if (call.getTypeClass() == null) {
      call.setResolveFailed(true);
      call.setFailure("type name cannot be resolved. ");
      return;
    }
  }
  boolean isSuperCall=false;
  List arglist=new ArrayList();
  Expression args=call.getArguments();
  if (args instanceof TupleExpression) {
    TupleExpression tupleExpression=(TupleExpression)args;
    List argexps=tupleExpression.getExpressions();
    for (int i=0; i < argexps.size(); i++) {
      Expression expression=(Expression)argexps.get(i);
      Class cls=expression.getTypeClass();
      if (cls == null) {
        call.setResolveFailed(true);
        return;
      }
 else {
        arglist.add(cls);
      }
    }
  }
 else   if (args instanceof ClosureExpression) {
    call.setResolveFailed(true);
    call.setFailure("don't know how to handle closure arg. ");
    return;
  }
 else {
    call.setResolveFailed(true);
    call.setFailure("unknown arg type: " + args.getClass().getName());
    return;
  }
  Class[] argsArray=new Class[arglist.size()];
  arglist.toArray(argsArray);
  Class ownerClass=call.getTypeClass();
  if (ownerClass == null) {
    String typeName=call.getType();
    if (typeName.equals(this.classNode.getName())) {
      call.setResolveFailed(true);
      call.setFailure("invoke constructor for this. no optimization for now");
      return;
    }
 else {
      try {
        ownerClass=loadClass(typeName);
        if (ownerClass == null) {
          call.setResolveFailed(true);
          call.setFailure("owner class type is null. ");
          return;
        }
      }
 catch (      Throwable th) {
        call.setResolveFailed(true);
        call.setFailure("Exception: " + th);
        return;
      }
    }
  }
  if (ownerClass == Object.class) {
    call.setResolveFailed(true);
    call.setFailure("owner class type java.lang.Object.  use late binding for dynamic types");
    return;
  }
 else   if (ownerClass == null) {
    call.setResolveFailed(true);
    call.setFailure("owner class type is null. use dynamic dispatching for GroovyObject");
    return;
  }
 else   if (ownerClass.isPrimitive()) {
    call.setResolveFailed(true);
    throwException("The owner of the constructor is primitive.");
    return;
  }
  Constructor ctor=MetaClassRegistry.getIntance(MetaClassRegistry.DONT_LOAD_DEFAULT).getDefinedConstructor(ownerClass,argsArray);
  if (ctor != null) {
    call.setConstructor(ctor);
  }
 else {
    call.setResolveFailed(true);
  }
  return;
}
