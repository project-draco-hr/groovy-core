{
  ArrayList<MetaMethod> res=new ArrayList<MetaMethod>();
  if (closure instanceof MethodClosure) {
    MethodClosure methodClosure=(MethodClosure)closure;
    Object owner=closure.getOwner();
    Class ownerClass=(Class)(owner instanceof Class ? owner : owner.getClass());
    for (    CachedMethod method : ReflectionCache.getCachedClass(ownerClass).getMethods()) {
      if (method.getName().equals(methodClosure.getMethod())) {
        res.add(new MethodClosureMetaMethod(name,declaringClass,closure,method));
      }
    }
  }
 else {
    if (closure instanceof GeneratedClosure) {
      for (      CachedMethod method : ReflectionCache.getCachedClass(closure.getClass()).getMethods()) {
        if (method.getName().equals("doCall")) {
          res.add(new ClosureMetaMethod(name,declaringClass,closure,method));
        }
      }
    }
 else {
      res.add(new MetaMethod(closure.getParameterTypes()){
        public int getModifiers(){
          return Modifier.PUBLIC;
        }
        public String getName(){
          return name;
        }
        public Class getReturnType(){
          return Object.class;
        }
        public CachedClass getDeclaringClass(){
          return ReflectionCache.getCachedClass(declaringClass);
        }
        public Object invoke(        Object object,        Object[] arguments){
          Closure cloned=(Closure)closure.clone();
          cloned.setDelegate(object);
          arguments=coerceArgumentsToClasses(arguments);
          return InvokerHelper.invokeMethod(closure,"call",arguments);
        }
      }
);
    }
  }
  return res;
}
