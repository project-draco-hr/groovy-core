{
  final Class selfClass=self.getTheClass();
  if (self instanceof HandleMetaClass) {
    self=(MetaClass)((HandleMetaClass)self).replaceDelegate();
  }
  if (!(self instanceof ExpandoMetaClass)) {
    if (self instanceof DelegatingMetaClass && ((DelegatingMetaClass)self).getAdaptee() instanceof ExpandoMetaClass) {
      self=((DelegatingMetaClass)self).getAdaptee();
    }
 else {
      throw new GroovyRuntimeException("Can't mixin methods to meta class: " + self);
    }
  }
  ExpandoMetaClass mc=(ExpandoMetaClass)self;
  ArrayList<MetaMethod> arr=new ArrayList<MetaMethod>();
  for (  Class categoryClass : categoryClasses) {
    final CachedClass cachedCategoryClass=ReflectionCache.getCachedClass(categoryClass);
    final MixinInMetaClass mixin=new MixinInMetaClass(mc,cachedCategoryClass);
    CachedMethod[] methods=cachedCategoryClass.getMethods();
    for (int i=0; i < methods.length; i++) {
      CachedMethod method=methods[i];
      final int mod=method.getModifiers();
      if (Modifier.isPublic(mod) && !method.getCachedMethod().isSynthetic()) {
        if (Modifier.isStatic(mod)) {
          staticMethod(self,arr,method);
        }
 else {
          if (self.pickMethod(method.getName(),method.getNativeParameterTypes()) == null) {
            arr.add(new MixinInstanceMetaMethod(method,mixin));
          }
        }
      }
    }
  }
  if (arr.isEmpty())   return;
  for (  Object res : arr) {
    final MetaMethod metaMethod=(MetaMethod)res;
    if (metaMethod.getDeclaringClass().isAssignableFrom(selfClass))     mc.registerInstanceMethod(metaMethod);
 else {
      mc.registerSubclassInstanceMethod(metaMethod);
    }
  }
}
