{
  if (adapter == invokeMethodOnCurrent && controller.optimizeForInt) {
    String methodName=getMethodName(message);
    if (methodName != null) {
      List<Parameter> plist=new ArrayList(16);
      TupleExpression args;
      if (arguments instanceof TupleExpression) {
        args=(TupleExpression)arguments;
        for (        Expression arg : args.getExpressions()) {
          plist.add(new Parameter(arg.getType(),""));
        }
      }
 else {
        args=new TupleExpression(receiver);
        plist.add(new Parameter(arguments.getType(),""));
      }
      Parameter[] parameters=plist.toArray(new Parameter[plist.size()]);
      MethodNode mn=controller.getClassNode().getMethod(methodName,parameters);
      if (mn != null) {
        MethodVisitor mv=controller.getMethodVisitor();
        int opcode=INVOKEVIRTUAL;
        if (mn.isStatic()) {
          opcode=INVOKESTATIC;
        }
 else         if (mn.isPrivate()) {
          opcode=INVOKESPECIAL;
        }
        if (opcode != INVOKESTATIC)         mv.visitIntInsn(ALOAD,0);
        for (        Expression arg : args.getExpressions()) {
          arg.visit(controller.getAcg());
        }
        String owner=BytecodeHelper.getClassInternalName(mn.getDeclaringClass());
        String desc=BytecodeHelper.getMethodDescriptor(mn.getReturnType(),mn.getParameters());
        mv.visitMethodInsn(opcode,owner,methodName,desc);
        controller.getOperandStack().replace(mn.getReturnType(),args.getExpressions().size());
        return;
      }
    }
  }
  if ((adapter == invokeMethod || adapter == invokeMethodOnCurrent || adapter == invokeStaticMethod) && !spreadSafe) {
    String methodName=getMethodName(message);
    if (methodName != null) {
      controller.getCallSiteWriter().makeCallSite(receiver,methodName,arguments,safe,implicitThis,adapter == invokeMethodOnCurrent,adapter == invokeStaticMethod);
      return;
    }
  }
  OperandStack operandStack=controller.getOperandStack();
  CompileStack compileStack=controller.getCompileStack();
  AsmClassGenerator acg=controller.getAcg();
  compileStack.pushLHS(false);
  if (adapter == AsmClassGenerator.setProperty) {
    ConstantExpression.NULL.visit(acg);
  }
 else {
    sender.visit(acg);
  }
  compileStack.pushImplicitThis(implicitThis);
  receiver.visit(acg);
  operandStack.box();
  compileStack.popImplicitThis();
  int operandsToRemove=2;
  if (message != null) {
    message.visit(acg);
    operandStack.box();
    operandsToRemove++;
  }
  boolean containsSpreadExpression=AsmClassGenerator.containsSpreadExpression(arguments);
  int numberOfArguments=containsSpreadExpression ? -1 : AsmClassGenerator.argumentSize(arguments);
  if (numberOfArguments > MethodCallerMultiAdapter.MAX_ARGS || containsSpreadExpression) {
    ArgumentListExpression ae;
    if (arguments instanceof ArgumentListExpression) {
      ae=(ArgumentListExpression)arguments;
    }
 else     if (arguments instanceof TupleExpression) {
      TupleExpression te=(TupleExpression)arguments;
      ae=new ArgumentListExpression(te.getExpressions());
    }
 else {
      ae=new ArgumentListExpression();
      ae.addExpression(arguments);
    }
    if (containsSpreadExpression) {
      acg.despreadList(ae.getExpressions(),true);
    }
 else {
      ae.visit(acg);
    }
  }
 else   if (numberOfArguments > 0) {
    operandsToRemove+=numberOfArguments;
    TupleExpression te=(TupleExpression)arguments;
    for (int i=0; i < numberOfArguments; i++) {
      Expression argument=te.getExpression(i);
      argument.visit(acg);
      operandStack.box();
      if (argument instanceof CastExpression)       acg.loadWrapper(argument);
    }
  }
  adapter.call(controller.getMethodVisitor(),numberOfArguments,safe,spreadSafe);
  compileStack.popLHS();
  operandStack.replace(ClassHelper.OBJECT_TYPE,operandsToRemove);
}
