{
  Reduction statement=null;
  if (lt() == Types.KEYWORD_STATIC && lt(2) == Types.LEFT_CURLY_BRACE) {
    if (!allowStatic) {
      controller.addError("static initializers not valid in this context",la());
    }
    Reduction modifiers=modifierList(true,false);
    Token identifier=Token.NULL;
    statement=methodDeclaration(modifiers,Reduction.EMPTY,identifier,false);
  }
 else {
    Reduction modifiers=modifierList(allowStatic,allowAbstract);
    if (lt() == Types.KEYWORD_CLASS) {
      statement=classDeclaration(modifiers);
    }
 else     if (lt() == Types.KEYWORD_INTERFACE) {
      statement=interfaceDeclaration(modifiers);
    }
 else {
      if (lt() == Types.KEYWORD_PROPERTY) {
        consume();
      }
      while (lt(true) == Types.NEWLINE) {
        consume(Types.NEWLINE);
      }
      CSTNode type=optionalDatatype(true,true);
      Token identifier=nameDeclaration(true);
switch (lt(true)) {
case Types.LEFT_PARENTHESIS:
{
          boolean methodIsAbstract=requireAbstract;
          if (!methodIsAbstract) {
            for (int i=1; i < modifiers.size(); i++) {
              if (modifiers.get(i).getMeaning() == Types.KEYWORD_ABSTRACT) {
                methodIsAbstract=true;
                break;
              }
            }
          }
          statement=methodDeclaration(modifiers,type,identifier,methodIsAbstract);
          break;
        }
case Types.EQUAL:
case Types.SEMICOLON:
case Types.NEWLINE:
case Types.RIGHT_CURLY_BRACE:
case Types.EOF:
      statement=propertyDeclaration(modifiers,type,identifier);
    break;
default :
  error(new int[]{Types.LEFT_PARENTHESIS,Types.EQUAL,Types.SEMICOLON,Types.NEWLINE,Types.RIGHT_CURLY_BRACE});
}
}
}
return statement;
}
