{
  CSTNode bodyStatement=null;
  CSTNode modifiers=new CSTNode();
  while (isModifier(lt())) {
    consume(modifiers,lt());
  }
  if (lt() == Token.KEYWORD_PROPERTY) {
    consume(lt());
  }
  while (lt_bare() == Token.NEWLINE) {
    consume_bare(lt_bare());
  }
  CSTNode type=new CSTNode();
  if (lt_bare() == Token.IDENTIFIER) {
switch (lt_bare(2)) {
case Token.DOT:
{
        type=datatype();
        break;
      }
case (Token.IDENTIFIER):
{
      type=new CSTNode(consume_bare(lt()));
      break;
    }
}
}
 else {
switch (lt_bare()) {
case (Token.KEYWORD_VOID):
case (Token.KEYWORD_INT):
case (Token.KEYWORD_FLOAT):
case (Token.KEYWORD_DOUBLE):
case (Token.KEYWORD_CHAR):
case (Token.KEYWORD_BYTE):
case (Token.KEYWORD_SHORT):
case (Token.KEYWORD_LONG):
case (Token.KEYWORD_BOOLEAN):
{
    type=new CSTNode(consume_bare(lt_bare()));
  }
}
}
CSTNode identifier=new CSTNode(consume_bare(Token.IDENTIFIER));
switch (lt_bare()) {
case Token.LEFT_PARENTHESIS:
bodyStatement=methodDeclaration(modifiers,type,identifier);
break;
case Token.EQUAL:
case Token.SEMICOLON:
case Token.NEWLINE:
case Token.RIGHT_CURLY_BRACE:
case -1:
bodyStatement=propertyDeclaration(modifiers,type,identifier);
optionalSemicolon();
break;
default :
throwExpected(new int[]{Token.LEFT_PARENTHESIS,Token.EQUAL,Token.SEMICOLON,Token.NEWLINE,Token.RIGHT_CURLY_BRACE});
}
return bodyStatement;
}
