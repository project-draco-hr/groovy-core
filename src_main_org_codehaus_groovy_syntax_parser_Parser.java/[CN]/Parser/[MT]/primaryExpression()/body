{
  CSTNode expr=null;
switch (lt()) {
case (Token.KEYWORD_TRUE):
case (Token.KEYWORD_FALSE):
case (Token.KEYWORD_NULL):
{
      expr=rootNode(lt());
      break;
    }
case (Token.LEFT_PARENTHESIS):
{
    consume(Token.LEFT_PARENTHESIS);
    expr=expression();
    consume(Token.RIGHT_PARENTHESIS);
    break;
  }
case (Token.KEYWORD_THIS):
case (Token.KEYWORD_SUPER):
case (Token.IDENTIFIER):
{
  CSTNode cur=rootNode(lt());
  while (lt() == Token.DOT) {
    cur=rootNode(Token.DOT,cur);
    consume(cur,Token.IDENTIFIER);
  }
  if (lt() == Token.LEFT_PARENTHESIS) {
switch (cur.getToken().getType()) {
case (Token.DOT):
{
        CSTNode newCur=rootNode(Token.LEFT_PARENTHESIS);
        newCur.addChild(cur.getChild(0));
        newCur.addChild(cur.getChild(1));
        cur=newCur;
        break;
      }
case (Token.IDENTIFIER):
{
      CSTNode newCur=rootNode(Token.LEFT_PARENTHESIS);
      newCur.addChild(new CSTNode());
      newCur.addChild(cur);
      cur=newCur;
      break;
    }
case (Token.KEYWORD_SUPER):
case (Token.KEYWORD_THIS):
{
    break;
  }
}
cur.addChild(argumentList());
consume(Token.RIGHT_PARENTHESIS);
}
expr=cur;
break;
}
case (Token.INTEGER_NUMBER):
case (Token.FLOAT_NUMBER):
case (Token.DOUBLE_QUOTE_STRING):
case (Token.SINGLE_QUOTE_STRING):
{
expr=rootNode(lt());
break;
}
case (Token.LEFT_SQUARE_BRACKET):
{
expr=listExpression();
break;
}
case (Token.LEFT_CURLY_BRACE):
{
expr=closureExpression();
break;
}
default :
{
throwExpected(new int[]{});
}
}
return expr;
}
