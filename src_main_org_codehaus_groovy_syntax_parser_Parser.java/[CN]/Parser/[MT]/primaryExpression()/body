{
  CSTNode expr=null;
  CSTNode identifier=null;
  PREFIX_SWITCH: switch (lt()) {
case (Token.KEYWORD_TRUE):
case (Token.KEYWORD_FALSE):
case (Token.KEYWORD_NULL):
{
      expr=rootNode(lt());
      break PREFIX_SWITCH;
    }
case (Token.KEYWORD_NEW):
{
    expr=newExpression();
    break PREFIX_SWITCH;
  }
case (Token.LEFT_PARENTHESIS):
{
  expr=parentheticalExpression();
  break PREFIX_SWITCH;
}
case (Token.INTEGER_NUMBER):
case (Token.FLOAT_NUMBER):
case (Token.DOUBLE_QUOTE_STRING):
case (Token.SINGLE_QUOTE_STRING):
{
expr=rootNode(lt());
break PREFIX_SWITCH;
}
case (Token.LEFT_SQUARE_BRACKET):
{
expr=listOrMapExpression();
break PREFIX_SWITCH;
}
case (Token.LEFT_CURLY_BRACE):
{
expr=closureExpression();
break PREFIX_SWITCH;
}
case (Token.KEYWORD_THIS):
{
expr=new CSTNode(Token.keyword(-1,-1,"this"));
identifier=rootNode(lt());
break PREFIX_SWITCH;
}
case (Token.KEYWORD_SUPER):
{
expr=new CSTNode(Token.keyword(-1,-1,"super"));
identifier=rootNode(lt());
break PREFIX_SWITCH;
}
case (Token.IDENTIFIER):
{
identifier=rootNode(lt());
expr=identifier;
break PREFIX_SWITCH;
}
default :
{
throwExpected(new int[]{});
}
}
if (identifier != null && (lt() == Token.LEFT_PARENTHESIS || (lt() == Token.LEFT_CURLY_BRACE && lt(2) == Token.PIPE))) {
if (expr == identifier) {
CSTNode replacementExpr=new CSTNode();
CSTNode resultExpr=sugaryMethodCallExpression(replacementExpr,identifier);
if (resultExpr != replacementExpr) {
expr=resultExpr;
}
}
 else {
expr=sugaryMethodCallExpression(expr,identifier);
}
}
DOT_LOOP: while (lt() == Token.DOT && lt(2) == Token.IDENTIFIER) {
CSTNode dotExpr=rootNode(Token.DOT);
identifier=rootNode(Token.IDENTIFIER);
DOT_TYPE_SWITCH: switch (lt()) {
case (Token.LEFT_PARENTHESIS):
case (Token.LEFT_CURLY_BRACE):
{
expr=sugaryMethodCallExpression(expr,identifier);
break DOT_TYPE_SWITCH;
}
default :
{
dotExpr.addChild(expr);
dotExpr.addChild(identifier);
expr=dotExpr;
break DOT_TYPE_SWITCH;
}
}
}
return expr;
}
