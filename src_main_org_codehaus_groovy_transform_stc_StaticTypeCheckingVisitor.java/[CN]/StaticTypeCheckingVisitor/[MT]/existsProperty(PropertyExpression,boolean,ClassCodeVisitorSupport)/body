{
  super.visitPropertyExpression(pexp);
  String propertyName=pexp.getPropertyAsString();
  if (propertyName == null)   return false;
  Expression objectExpression=pexp.getObjectExpression();
  final ClassNode objectExpressionType=getType(objectExpression);
  boolean staticOnlyAccess=objectExpressionType.equals(CLASS_Type);
  if (objectExpressionType.isArray() && "length".equals(pexp.getPropertyAsString())) {
    storeType(pexp,int_TYPE);
    if (visitor != null) {
      PropertyNode node=new PropertyNode("length",Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL,int_TYPE,objectExpressionType,null,null,null);
      visitor.visitProperty(node);
    }
    return true;
  }
  boolean foundGetterOrSetter=false;
  List<Receiver<String>> receivers=new LinkedList<Receiver<String>>();
  List<Receiver<String>> owners=makeOwnerList(objectExpression);
  addReceivers(receivers,owners,pexp.isImplicitThis());
  String capName=MetaClassHelper.capitalize(propertyName);
  boolean isAttributeExpression=pexp instanceof AttributeExpression;
  HashSet<ClassNode> handledNodes=new HashSet<ClassNode>();
  for (  Receiver<String> receiver : receivers) {
    ClassNode testClass=receiver.getType();
    LinkedList<ClassNode> queue=new LinkedList<ClassNode>();
    queue.add(testClass);
    while (!queue.isEmpty()) {
      ClassNode current=queue.removeFirst();
      if (handledNodes.contains(current))       continue;
      handledNodes.add(current);
      Set<ClassNode> allInterfaces=current.getAllInterfaces();
      for (      ClassNode intf : allInterfaces) {
        queue.add(GenericsUtils.parameterizeType(current,intf));
      }
      boolean staticOnly;
      if (current.equals(CLASS_Type)) {
        staticOnly=false;
      }
 else {
        staticOnly=staticOnlyAccess;
      }
      FieldNode field=current.getDeclaredField(propertyName);
      field=allowStaticAccessToMember(field,staticOnly);
      if (storeField(field,isAttributeExpression,pexp,objectExpressionType,visitor,receiver.getData()))       return true;
      PropertyNode propertyNode=current.getProperty(propertyName);
      propertyNode=allowStaticAccessToMember(propertyNode,staticOnly);
      if (storeProperty(propertyNode,pexp,objectExpressionType,visitor,receiver.getData()))       return true;
      boolean isThisExpression=objectExpression instanceof VariableExpression && ((VariableExpression)objectExpression).isThisExpression();
      if (storeField(field,isThisExpression,pexp,objectExpressionType,visitor,receiver.getData()))       return true;
      MethodNode getter=current.getGetterMethod("get" + capName);
      getter=allowStaticAccessToMember(getter,staticOnly);
      if (getter == null)       getter=current.getGetterMethod("is" + capName);
      getter=allowStaticAccessToMember(getter,staticOnly);
      MethodNode setter=current.getSetterMethod("set" + capName,false);
      setter=allowStaticAccessToMember(setter,staticOnly);
      if (visitor != null && getter != null)       visitor.visitMethod(getter);
      if (readMode) {
        if (getter != null) {
          ClassNode cn=inferReturnTypeGenerics(current,getter,ArgumentListExpression.EMPTY_ARGUMENTS);
          storeInferredTypeForPropertyExpression(pexp,cn);
          pexp.removeNodeMetaData(StaticTypesMarker.READONLY_PROPERTY);
          String delegationData=receiver.getData();
          if (delegationData != null)           pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER,delegationData);
          return true;
        }
      }
 else {
        if (setter != null) {
          if (visitor != null && field != null)           visitor.visitField(field);
          storeType(pexp,setter.getParameters()[0].getType());
          SetterInfo info=new SetterInfo(current,setter);
          BinaryExpression enclosingBinaryExpression=typeCheckingContext.getEnclosingBinaryExpression();
          if (enclosingBinaryExpression != null)           putSetterInfo(enclosingBinaryExpression.getLeftExpression(),info);
          String delegationData=receiver.getData();
          if (delegationData != null)           pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER,delegationData);
          return true;
        }
 else         if (getter != null) {
          pexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY,true);
        }
      }
      foundGetterOrSetter=foundGetterOrSetter || setter != null || getter != null;
      if (storeField(field,true,pexp,objectExpressionType,visitor,receiver.getData()))       return true;
      if (current.getSuperClass() != null) {
        queue.add(current.getSuperClass());
      }
    }
    List<MethodNode> methods=findDGMMethodsByNameAndArguments(getSourceUnit().getClassLoader(),testClass,"get" + capName,ClassNode.EMPTY_ARRAY);
    if (!methods.isEmpty()) {
      List<MethodNode> methodNodes=chooseBestMethod(testClass,methods,ClassNode.EMPTY_ARRAY);
      if (methodNodes.size() == 1) {
        MethodNode getter=methodNodes.get(0);
        if (visitor != null) {
          visitor.visitMethod(getter);
        }
        ClassNode cn=inferReturnTypeGenerics(testClass,getter,ArgumentListExpression.EMPTY_ARGUMENTS);
        storeInferredTypeForPropertyExpression(pexp,cn);
        return true;
      }
    }
  }
  for (  Receiver<String> receiver : receivers) {
    ClassNode testClass=receiver.getType();
    ClassNode propertyType=getTypeForMapPropertyExpression(testClass,objectExpressionType,pexp);
    if (propertyType == null)     propertyType=getTypeForListPropertyExpression(testClass,objectExpressionType,pexp);
    if (propertyType == null)     propertyType=getTypeForSpreadExpression(testClass,objectExpressionType,pexp);
    if (propertyType == null)     continue;
    if (visitor != null) {
      PropertyNode node=new PropertyNode(propertyName,Opcodes.ACC_PUBLIC,propertyType,objectExpressionType,null,null,null);
      visitor.visitProperty(node);
    }
    storeType(pexp,propertyType);
    String delegationData=receiver.getData();
    if (delegationData != null)     pexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER,delegationData);
    return true;
  }
  return foundGetterOrSetter;
}
