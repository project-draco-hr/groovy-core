{
  ClassNode cn=(ClassNode)exp.getNodeMetaData(StaticTypesTransformation.StaticTypesMarker.INFERRED_TYPE);
  if (cn != null)   return cn;
  if (exp instanceof VariableExpression) {
    VariableExpression vexp=(VariableExpression)exp;
    if (vexp == VariableExpression.THIS_EXPRESSION)     return classNode;
    if (vexp == VariableExpression.SUPER_EXPRESSION)     return classNode.getSuperClass();
    final Variable variable=vexp.getAccessedVariable();
    if (variable != null && variable != vexp && variable instanceof VariableExpression) {
      return getType((Expression)variable);
    }
  }
 else   if (exp instanceof PropertyExpression) {
    PropertyExpression pexp=(PropertyExpression)exp;
    if (pexp.getObjectExpression().getType().isEnum()) {
      return pexp.getObjectExpression().getType();
    }
 else {
      ClassNode clazz=pexp.getObjectExpression().getType().redirect();
      List<ClassNode> candidates=new LinkedList<ClassNode>();
      candidates.add(clazz);
      if (!temporaryIfBranchTypeInformation.empty()) {
        List<ClassNode> classNodes=temporaryIfBranchTypeInformation.peek().get(extractTemporaryTypeInfoKey(pexp.getObjectExpression()));
        if (classNodes != null && !classNodes.isEmpty())         candidates.addAll(classNodes);
      }
      String propertyName=pexp.getPropertyAsString();
      boolean isAttributeExpression=pexp instanceof AttributeExpression;
      for (      ClassNode candidate : candidates) {
        ClassNode parent=candidate;
        while (parent != null) {
          parent=parent.redirect();
          PropertyNode propertyNode=parent.getProperty(propertyName);
          if (propertyNode != null)           return propertyNode.getType();
          if (!isAttributeExpression) {
            FieldNode field=parent.getDeclaredField(propertyName);
            if (field != null)             return field.getType();
          }
          parent=isAttributeExpression ? null : parent.getSuperClass();
        }
      }
      return ClassHelper.OBJECT_TYPE;
    }
  }
  if (exp instanceof ListExpression) {
    ListExpression list=(ListExpression)exp;
    List<Expression> expressions=list.getExpressions();
    GenericsType[] genericsTypes=exp.getType().getGenericsTypes();
    if ((genericsTypes == null || genericsTypes.length == 0 || (genericsTypes.length == 1 && OBJECT_TYPE.equals(genericsTypes[0].getType()))) && (!expressions.isEmpty())) {
      List<ClassNode> nodes=new LinkedList<ClassNode>();
      for (      Expression expression : expressions) {
        nodes.add(getType(expression));
      }
      ClassNode superType=firstCommonSuperType(nodes);
      if (!OBJECT_TYPE.equals(superType)) {
        ClassNode orig=exp.getType();
        ClassNode inferred=new ClassNode(orig.getName(),orig.getModifiers(),orig.getSuperClass(),orig.getInterfaces(),orig.getMixins());
        inferred.setGenericsTypes(new GenericsType[]{new GenericsType(superType)});
        return inferred;
      }
    }
  }
  return exp.getType();
}
