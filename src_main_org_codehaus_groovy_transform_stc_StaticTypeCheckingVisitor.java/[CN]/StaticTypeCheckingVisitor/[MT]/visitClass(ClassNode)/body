{
  if (shouldSkipClassNode(node))   return;
  Object type=node.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
  if (type != null) {
    typeCheckingContext.errorCollector=new ErrorCollector(typeCheckingContext.errorCollector.getConfiguration());
  }
  ClassNode oldCN=typeCheckingContext.enclosingClassNode;
  typeCheckingContext.enclosingClassNode=node;
  Set<MethodNode> oldVisitedMethod=typeCheckingContext.alreadyVisitedMethods;
  typeCheckingContext.alreadyVisitedMethods=new LinkedHashSet<MethodNode>();
  super.visitClass(node);
  Iterator<InnerClassNode> innerClasses=typeCheckingContext.enclosingClassNode.getInnerClasses();
  while (innerClasses.hasNext()) {
    InnerClassNode innerClassNode=innerClasses.next();
    visitClass(innerClassNode);
  }
  typeCheckingContext.alreadyVisitedMethods=oldVisitedMethod;
  typeCheckingContext.enclosingClassNode=oldCN;
  node.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE,node);
  for (  MethodNode methodNode : node.getMethods()) {
    methodNode.putNodeMetaData(StaticTypeCheckingVisitor.class,Boolean.TRUE);
  }
  for (  ConstructorNode constructorNode : node.getDeclaredConstructors()) {
    constructorNode.putNodeMetaData(StaticTypeCheckingVisitor.class,Boolean.TRUE);
  }
}
