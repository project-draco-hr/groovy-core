{
  ClassNode cn=(ClassNode)exp.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
  if (cn != null)   return cn;
  if (exp instanceof VariableExpression) {
    VariableExpression vexp=(VariableExpression)exp;
    if (vexp == VariableExpression.THIS_EXPRESSION)     return classNode;
    if (vexp == VariableExpression.SUPER_EXPRESSION)     return classNode.getSuperClass();
    final Variable variable=vexp.getAccessedVariable();
    if (variable != null && variable != vexp && variable instanceof VariableExpression) {
      return getType((Expression)variable);
    }
    if (variable instanceof Parameter) {
      Parameter parameter=(Parameter)variable;
      ClassNode type=forLoopVariableTypes.get(parameter);
      if (type != null)       return type;
    }
  }
 else   if (exp instanceof PropertyExpression) {
    PropertyExpression pexp=(PropertyExpression)exp;
    ClassNode objectExpType=getType(pexp.getObjectExpression());
    if ((LIST_TYPE.equals(objectExpType) || objectExpType.implementsInterface(LIST_TYPE)) && pexp.isSpreadSafe()) {
      return LIST_TYPE;
    }
 else     if ((objectExpType.equals(MAP_TYPE) || objectExpType.implementsInterface(MAP_TYPE)) && pexp.isSpreadSafe()) {
      String propertyName=pexp.getPropertyAsString();
      GenericsType[] types=objectExpType.getGenericsTypes();
      if ("key".equals(propertyName)) {
        if (types.length == 2) {
          ClassNode listKey=new ClassNode(List.class);
          listKey.setGenericsTypes(new GenericsType[]{types[0]});
          return listKey;
        }
      }
 else       if ("value".equals(propertyName)) {
        if (types.length == 2) {
          ClassNode listValue=new ClassNode(List.class);
          listValue.setGenericsTypes(new GenericsType[]{types[1]});
          return listValue;
        }
      }
 else {
        addStaticTypeError("Spread operator on map only allows one of [key,value]",pexp);
      }
      return LIST_TYPE;
    }
 else     if (objectExpType.isEnum()) {
      return objectExpType;
    }
 else {
      final AtomicReference<ClassNode> result=new AtomicReference<ClassNode>(ClassHelper.VOID_TYPE);
      existsProperty(pexp,false,new PropertyLookupVisitor(result));
      return result.get();
    }
  }
  if (exp instanceof ListExpression) {
    return inferListExpressionType((ListExpression)exp);
  }
 else   if (exp instanceof MapExpression) {
    return inferMapExpressionType((MapExpression)exp);
  }
  if (exp instanceof MethodNode) {
    ClassNode ret=(ClassNode)exp.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);
    return ret != null ? ret : ((MethodNode)exp).getReturnType();
  }
  if (exp instanceof ClosureExpression) {
    ClassNode irt=(ClassNode)exp.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);
    if (irt != null) {
      irt=wrapTypeIfNecessary(irt);
      ClassNode result=CLOSURE_TYPE.getPlainNodeReference();
      result.setGenericsTypes(new GenericsType[]{new GenericsType(irt)});
      return result;
    }
  }
  return exp instanceof VariableExpression ? ((VariableExpression)exp).getOriginType() : ((Expression)exp).getType();
}
