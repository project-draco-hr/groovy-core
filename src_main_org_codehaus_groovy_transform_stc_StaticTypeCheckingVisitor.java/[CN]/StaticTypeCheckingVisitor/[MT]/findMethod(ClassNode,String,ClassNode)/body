{
  if (isPrimitiveType(receiver))   receiver=getWrapper(receiver);
  List<MethodNode> methods;
  if ("<init>".equals(name)) {
    methods=new ArrayList<MethodNode>(receiver.getDeclaredConstructors());
    if (methods.isEmpty()) {
      MethodNode node=new ConstructorNode(Opcodes.ACC_PUBLIC,Parameter.EMPTY_ARRAY,ClassNode.EMPTY_ARRAY,EmptyStatement.INSTANCE);
      node.setDeclaringClass(receiver);
      return Collections.singletonList(node);
    }
  }
 else {
    methods=receiver.getMethods(name);
    if (receiver.isInterface()) {
      collectAllInterfaceMethodsByName(receiver,name,methods);
      methods.addAll(OBJECT_TYPE.getMethods(name));
    }
    if (typeCheckingContext.closureExpression == null) {
      ClassNode parent=receiver;
      while (parent instanceof InnerClassNode && !parent.isStaticClass()) {
        parent=receiver.getOuterClass();
        methods.addAll(parent.getMethods(name));
      }
    }
    if (methods.isEmpty() && (args == null || args.length == 0)) {
      String pname=null;
      if (name.startsWith("get")) {
        pname=java.beans.Introspector.decapitalize(name.substring(3));
      }
 else       if (name.startsWith("is")) {
        pname=java.beans.Introspector.decapitalize(name.substring(2));
      }
      if (pname != null) {
        PropertyNode property=null;
        ClassNode curNode=receiver;
        while (property == null && curNode != null) {
          property=curNode.getProperty(pname);
          curNode=curNode.getSuperClass();
        }
        if (property != null) {
          MethodNode node=new MethodNode(name,Opcodes.ACC_PUBLIC,property.getType(),Parameter.EMPTY_ARRAY,ClassNode.EMPTY_ARRAY,EmptyStatement.INSTANCE);
          if (property.isStatic()) {
            node.setModifiers(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC);
          }
          node.setDeclaringClass(receiver);
          return Collections.singletonList(node);
        }
      }
    }
 else     if (methods.isEmpty() && args != null && args.length == 1) {
      if (name.startsWith("set")) {
        String pname=java.beans.Introspector.decapitalize(name.substring(3));
        ClassNode curNode=receiver;
        PropertyNode property=null;
        while (property == null && curNode != null) {
          property=curNode.getProperty(pname);
          curNode=curNode.getSuperClass();
        }
        if (property != null) {
          ClassNode type=property.getOriginType();
          if (implementsInterfaceOrIsSubclassOf(args[0],type)) {
            MethodNode node=new MethodNode(name,Opcodes.ACC_PUBLIC,VOID_TYPE,new Parameter[]{new Parameter(type,"arg")},ClassNode.EMPTY_ARRAY,EmptyStatement.INSTANCE);
            if (property.isStatic()) {
              node.setModifiers(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC);
            }
            node.setDeclaringClass(receiver);
            return Collections.singletonList(node);
          }
        }
      }
    }
  }
  if (methods.isEmpty()) {
    collectAllInterfaceMethodsByName(receiver,name,methods);
  }
  List<MethodNode> chosen=chooseBestMethod(receiver,methods,args);
  if (!chosen.isEmpty())   return chosen;
  if (receiver instanceof InnerClassNode && ((InnerClassNode)receiver).isAnonymous() && methods.size() == 1 && args != null && "<init>".equals(name)) {
    MethodNode constructor=methods.get(0);
    if (constructor.getParameters().length == args.length) {
      return methods;
    }
  }
  if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes() != null) {
    List<MethodNode> result=findMethod(receiver.getGenericsTypes()[0].getType(),name,args);
    if (!result.isEmpty())     return result;
  }
  methods.clear();
  chosen=findDGMMethodsByNameAndArguments(receiver,name,args,methods);
  if (!chosen.isEmpty()) {
    return chosen;
  }
  if (ClassHelper.GSTRING_TYPE.equals(receiver))   return findMethod(ClassHelper.STRING_TYPE,name,args);
  return EMPTY_METHODNODE_LIST;
}
