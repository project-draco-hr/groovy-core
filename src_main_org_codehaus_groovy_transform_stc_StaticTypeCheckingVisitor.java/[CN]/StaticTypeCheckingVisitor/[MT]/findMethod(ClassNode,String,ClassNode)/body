{
  if (isPrimitiveType(receiver))   receiver=getWrapper(receiver);
  List<MethodNode> methods;
  if ("<init>".equals(name)) {
    methods=new ArrayList<MethodNode>(receiver.getDeclaredConstructors());
    if (methods.isEmpty()) {
      MethodNode node=new ConstructorNode(Opcodes.ACC_PUBLIC,Parameter.EMPTY_ARRAY,ClassNode.EMPTY_ARRAY,EmptyStatement.INSTANCE);
      node.setDeclaringClass(receiver);
      return Collections.singletonList(node);
    }
  }
 else {
    methods=receiver.getMethods(name);
    if (receiver.isInterface()) {
      ClassNode[] interfaces=receiver.getInterfaces();
      if (interfaces != null && interfaces.length > 0) {
        methods=new ArrayList<MethodNode>(methods);
        for (        ClassNode node : interfaces) {
          List<MethodNode> intfMethods=node.getMethods(name);
          methods.addAll(intfMethods);
        }
      }
      methods.addAll(OBJECT_TYPE.getMethods(name));
    }
    if (closureExpression == null) {
      ClassNode parent=receiver;
      while (parent instanceof InnerClassNode && !parent.isStaticClass()) {
        parent=receiver.getOuterClass();
        methods.addAll(parent.getMethods(name));
      }
    }
    if (methods.isEmpty() && (args == null || args.length == 0)) {
      String pname=null;
      if (name.startsWith("get")) {
        pname=java.beans.Introspector.decapitalize(name.substring(3));
      }
 else       if (name.startsWith("is")) {
        pname=java.beans.Introspector.decapitalize(name.substring(2));
      }
      if (pname != null) {
        PropertyNode property=null;
        ClassNode curNode=receiver;
        while (property == null && curNode != null) {
          property=curNode.getProperty(pname);
          curNode=curNode.getSuperClass();
        }
        if (property != null) {
          MethodNode node=new MethodNode(name,Opcodes.ACC_PUBLIC,property.getType(),Parameter.EMPTY_ARRAY,ClassNode.EMPTY_ARRAY,EmptyStatement.INSTANCE);
          node.setDeclaringClass(receiver);
          return Collections.singletonList(node);
        }
      }
    }
 else     if (methods.isEmpty() && args != null && args.length == 1) {
      if (name.startsWith("set")) {
        String pname=java.beans.Introspector.decapitalize(name.substring(3));
        ClassNode curNode=receiver;
        PropertyNode property=null;
        while (property == null && curNode != null) {
          property=curNode.getProperty(pname);
          curNode=curNode.getSuperClass();
        }
        if (property != null) {
          ClassNode type=property.getOriginType();
          if (implementsInterfaceOrIsSubclassOf(args[0],type)) {
            MethodNode node=new MethodNode(name,Opcodes.ACC_PUBLIC,VOID_TYPE,new Parameter[]{new Parameter(type,"arg")},ClassNode.EMPTY_ARRAY,EmptyStatement.INSTANCE);
            node.setDeclaringClass(receiver);
            return Collections.singletonList(node);
          }
        }
      }
    }
  }
  List<MethodNode> chosen=chooseBestMethod(receiver,methods,args);
  if (!chosen.isEmpty())   return chosen;
  if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes() != null) {
    List<MethodNode> result=findMethod(receiver.getGenericsTypes()[0].getType(),name,args);
    if (!result.isEmpty())     return result;
  }
  methods.clear();
  chosen=findDGMMethodsByNameAndArguments(receiver,name,args,methods);
  if (!chosen.isEmpty()) {
    return chosen;
  }
  if (receiver == ClassHelper.GSTRING_TYPE)   return findMethod(ClassHelper.STRING_TYPE,name,args);
  if (pluginFactory != null) {
    TypeCheckerPlugin plugin=pluginFactory.getTypeCheckerPlugin(classNode);
    if (plugin != null) {
      List<MethodNode> methodNodes=plugin.findMethod(receiver,name,args);
      if (methodNodes != null && !methodNodes.isEmpty())       return methodNodes;
    }
  }
  return EMPTY_METHODNODE_LIST;
}
