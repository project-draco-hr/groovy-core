{
  ClassNode leftRedirect;
  if (isArrayAccessExpression(leftExpression) || leftExpression instanceof PropertyExpression || (leftExpression instanceof VariableExpression && ((VariableExpression)leftExpression).getAccessedVariable() instanceof DynamicVariable)) {
    leftRedirect=leftExpressionType;
  }
 else {
    leftRedirect=leftExpression.getType().redirect();
  }
  boolean compatible=checkCompatibleAssignmentTypes(leftRedirect,inferredRightExpressionType);
  if (!compatible) {
    addStaticTypeError("Cannot assign value of type " + inferredRightExpressionType.getName() + " to variable of type "+ leftExpressionType.getName(),assignmentExpression);
  }
 else {
    if (rightExpression instanceof ClosureExpression) {
      Object type=rightExpression.getNodeMetaData(StaticTypesTransformation.StaticTypesMarker.CLOSURE_INFERRED_RETURN_TYPE);
      if (type != null) {
        leftExpression.putNodeMetaData(StaticTypesTransformation.StaticTypesMarker.CLOSURE_INFERRED_RETURN_TYPE,type);
      }
    }
    boolean possibleLooseOfPrecision=false;
    if (isNumberType(leftRedirect) && isNumberType(inferredRightExpressionType)) {
      possibleLooseOfPrecision=checkPossibleLooseOfPrecision(leftRedirect,inferredRightExpressionType,rightExpression);
      if (possibleLooseOfPrecision) {
        addStaticTypeError("Possible loose of precision from " + inferredRightExpressionType + " to "+ leftRedirect,rightExpression);
      }
    }
    if (!possibleLooseOfPrecision && leftExpressionType.isArray()) {
      ClassNode leftComponentType=leftExpressionType.getComponentType();
      ClassNode rightRedirect=rightExpression.getType().redirect();
      if (rightRedirect.isArray()) {
        ClassNode rightComponentType=rightRedirect.getComponentType();
        if (!checkCompatibleAssignmentTypes(leftComponentType,rightComponentType)) {
          addStaticTypeError("Cannot assign value of type " + rightComponentType + " into array of type "+ leftExpressionType,assignmentExpression);
        }
      }
 else       if (rightExpression instanceof ListExpression) {
        for (        Expression element : ((ListExpression)rightExpression).getExpressions()) {
          ClassNode rightComponentType=element.getType().redirect();
          if (!checkCompatibleAssignmentTypes(leftComponentType,rightComponentType)) {
            addStaticTypeError("Cannot assign value of type " + rightComponentType + " into array of type "+ leftExpressionType,assignmentExpression);
          }
        }
      }
    }
    if (!implementsInterfaceOrIsSubclassOf(leftRedirect,LIST_TYPE) && rightExpression instanceof ListExpression) {
      ArgumentListExpression argList=new ArgumentListExpression(((ListExpression)rightExpression).getExpressions());
      ClassNode[] args=getArgumentTypes(argList);
      checkGroovyStyleConstructor(leftRedirect,args);
    }
 else     if (!implementsInterfaceOrIsSubclassOf(inferredRightExpressionType,leftRedirect) && implementsInterfaceOrIsSubclassOf(inferredRightExpressionType,LIST_TYPE)) {
      addStaticTypeError("Cannot assign value of type " + inferredRightExpressionType.getName() + " to variable of type "+ leftExpressionType.getName(),assignmentExpression);
    }
    if (!leftRedirect.implementsInterface(ClassHelper.MAP_TYPE) && rightExpression instanceof MapExpression) {
      ArgumentListExpression argList=new ArgumentListExpression(rightExpression);
      ClassNode[] args=getArgumentTypes(argList);
      checkGroovyStyleConstructor(leftRedirect,args);
      MapExpression mapExpression=(MapExpression)rightExpression;
      for (      MapEntryExpression entryExpression : mapExpression.getMapEntryExpressions()) {
        Expression keyExpr=entryExpression.getKeyExpression();
        if (!(keyExpr instanceof ConstantExpression)) {
          addStaticTypeError("Dynamic keys in map-style constructors are unsupported in static type checking",keyExpr);
        }
 else {
          String property=keyExpr.getText();
          ClassNode currentNode=leftRedirect;
          PropertyNode propertyNode=null;
          while (propertyNode == null && currentNode != null) {
            propertyNode=currentNode.getProperty(property);
            currentNode=currentNode.getSuperClass();
          }
          if (propertyNode == null) {
            addStaticTypeError("No such property: " + property + " for class: "+ leftRedirect.getName(),leftExpression);
          }
 else {
            ClassNode valueType=getType(entryExpression.getValueExpression());
            if (!isAssignableTo(propertyNode.getType(),valueType)) {
              addStaticTypeError("Cannot assign value of type " + valueType.getName() + " to field of type "+ propertyNode.getType().getName(),entryExpression);
            }
          }
        }
      }
    }
    if (leftExpressionType.isUsingGenerics() && !leftExpressionType.isEnum()) {
      final AtomicBoolean ok=new AtomicBoolean(false);
      GenericsUtils.ClassNodeCollector collector=new GenericsUtils.ClassNodeCollector(){
        public boolean collect(        final ClassNode node){
          if (node.equals(leftExpressionType)) {
            boolean check=true;
            GenericsType[] nodeGenericsTypes=node.getGenericsTypes();
            GenericsType[] genericsTypes=leftExpressionType.getGenericsTypes();
            if (nodeGenericsTypes == null || genericsTypes == null)             return true;
            if (nodeGenericsTypes.length != genericsTypes.length)             return true;
            for (int i=0; i < genericsTypes.length; i++) {
              ClassNode genericsType=getWrapper(genericsTypes[i].getType());
              ClassNode nodeType=getWrapper(nodeGenericsTypes[i].getType());
              check=check && (genericsType.equals(nodeType) || nodeType.isDerivedFrom(genericsType));
            }
            if (check) {
              ok.set(true);
              return false;
            }
          }
          return true;
        }
      }
;
      GenericsUtils.collectParameterizedClassInfo(inferredRightExpressionType,collector);
      if (!ok.get()) {
        addStaticTypeError("Incompatible generic argument types. Cannot assign " + inferredRightExpressionType.toString(false) + " to: "+ leftExpressionType.toString(false),assignmentExpression);
      }
    }
  }
}
