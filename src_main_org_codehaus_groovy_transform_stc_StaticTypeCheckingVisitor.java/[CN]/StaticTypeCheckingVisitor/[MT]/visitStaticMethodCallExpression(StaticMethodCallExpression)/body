{
  final String name=call.getMethod();
  if (name == null) {
    addStaticTypeError("cannot resolve dynamic method name at compile time.",call);
    return;
  }
  if (extension.beforeMethodCall(call)) {
    extension.afterMethodCall(call);
    return;
  }
  final ClassNode rememberLastItType=typeCheckingContext.lastImplicitItType;
  Expression callArguments=call.getArguments();
  ArgumentListExpression argumentList=InvocationWriter.makeArgumentList(callArguments);
  checkForbiddenSpreadArgument(argumentList);
  boolean isWithCall=isWithCall(name,callArguments);
  visitMethodCallArguments(argumentList,false,null);
  ClassNode[] args=getArgumentTypes(argumentList);
  final ClassNode receiver=call.getOwnerType();
  if (isWithCall) {
    typeCheckingContext.lastImplicitItType=receiver;
    checkClosureParameters(callArguments,receiver);
  }
  try {
    if (isWithCall) {
      callArguments.visit(this);
    }
    List<Receiver<String>> receivers=new LinkedList<Receiver<String>>();
    addReceivers(receivers,makeOwnerList(new ClassExpression(receiver)),false);
    List<MethodNode> mn=null;
    Receiver<String> chosenReceiver=null;
    for (    Receiver<String> currentReceiver : receivers) {
      mn=findMethod(currentReceiver.getType(),name,args);
      if (!mn.isEmpty()) {
        if (mn.size() == 1)         typeCheckMethodsWithGenerics(currentReceiver.getType(),args,mn.get(0),call);
        chosenReceiver=currentReceiver;
        break;
      }
    }
    if (mn.isEmpty()) {
      mn=extension.handleMissingMethod(receiver,name,argumentList,args,call);
    }
    boolean callArgsVisited=false;
    if (mn.isEmpty()) {
      addNoMatchingMethodError(receiver,name,args,call);
    }
 else {
      mn=disambiguateMethods(mn,call);
      if (mn.size() == 1) {
        MethodNode directMethodCallCandidate=mn.get(0);
        typeCheckingContext.pushEnclosingClassNode(directMethodCallCandidate.getDeclaringClass());
        for (        ClassNode node : typeCheckingContext.source.getAST().getClasses()) {
          if (isClassInnerClassOrEqualTo(typeCheckingContext.getEnclosingClassNode(),node)) {
            silentlyVisitMethodNode(directMethodCallCandidate);
            break;
          }
        }
        pickInferredTypeFromMethodAnnotation(directMethodCallCandidate);
        typeCheckingContext.popEnclosingClassNode();
        ClassNode returnType=getType(directMethodCallCandidate);
        if (returnType.isUsingGenerics() && !returnType.isEnum()) {
          visitMethodCallArguments(argumentList,true,(MethodNode)call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET));
          ClassNode irtg=inferReturnTypeGenerics(chosenReceiver.getType(),directMethodCallCandidate,callArguments);
          returnType=irtg != null && implementsInterfaceOrIsSubclassOf(irtg,returnType) ? irtg : returnType;
          callArgsVisited=true;
        }
        storeType(call,returnType);
        storeTargetMethod(call,directMethodCallCandidate);
      }
 else {
        addAmbiguousErrorMessage(mn,name,args,call);
      }
      if (!callArgsVisited) {
        visitMethodCallArguments(argumentList,true,(MethodNode)call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET));
      }
    }
  }
  finally {
    if (isWithCall) {
      typeCheckingContext.lastImplicitItType=rememberLastItType;
    }
    extension.afterMethodCall(call);
  }
}
