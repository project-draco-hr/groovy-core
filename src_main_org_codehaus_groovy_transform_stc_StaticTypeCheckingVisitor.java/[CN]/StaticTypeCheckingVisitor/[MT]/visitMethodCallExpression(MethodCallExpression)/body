{
  final String name=call.getMethodAsString();
  if (name == null) {
    addStaticTypeError("cannot resolve dynamic method name at compile time.",call.getMethod());
    return;
  }
  final Expression objectExpression=call.getObjectExpression();
  objectExpression.visit(this);
  call.getMethod().visit(this);
  final ClassNode rememberLastItType=lastImplicitItType;
  Expression callArguments=call.getArguments();
  boolean isWithCall=isWithCall(name,callArguments);
  if (!isWithCall) {
    callArguments.visit(this);
  }
  ClassNode[] args=getArgumentTypes(InvocationWriter.makeArgumentList(callArguments),classNode);
  final ClassNode receiver=getType(objectExpression,classNode);
  if (isWithCall) {
    withReceiverList.add(0,receiver);
    lastImplicitItType=receiver;
    if (callArguments instanceof ArgumentListExpression) {
      ArgumentListExpression argList=(ArgumentListExpression)callArguments;
      ClosureExpression closure=(ClosureExpression)argList.getExpression(0);
      Parameter[] parameters=closure.getParameters();
      if (parameters.length > 1) {
        addStaticTypeError("Unexpected number of parameters for a with call",argList);
      }
 else       if (parameters.length == 1) {
        Parameter param=parameters[0];
        if (!param.isDynamicTyped() && !isAssignableTo(param.getType().redirect(),receiver)) {
          addStaticTypeError("Expected parameter type: " + receiver + " but was: "+ param.getType().redirect(),param);
        }
      }
    }
  }
  try {
    if (isWithCall) {
      callArguments.visit(this);
    }
    List<ClassNode> receivers=new LinkedList<ClassNode>();
    if (!withReceiverList.isEmpty())     receivers.addAll(withReceiverList);
    receivers.add(receiver);
    if (!temporaryIfBranchTypeInformation.empty()) {
      final Map<Object,List<ClassNode>> tempo=temporaryIfBranchTypeInformation.peek();
      Object key=extractTemporaryTypeInfoKey(objectExpression);
      List<ClassNode> potentialReceiverType=tempo.get(key);
      if (potentialReceiverType != null)       receivers.addAll(potentialReceiverType);
    }
    MethodNode mn=null;
    for (    ClassNode currentReceiver : receivers) {
      mn=findMethod(currentReceiver,name,args);
      if (mn != null)       break;
    }
    if (mn == null) {
      addStaticTypeError("Cannot find matching method " + receiver.getName() + "#"+ toMethodParametersString(name,args),call);
    }
 else {
      storeType(call,mn.getReturnType());
    }
  }
  finally {
    if (isWithCall) {
      lastImplicitItType=rememberLastItType;
      withReceiverList.removeFirst();
    }
  }
}
