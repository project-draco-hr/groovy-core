{
  final String name=call.getMethodAsString();
  if (name == null) {
    addStaticTypeError("cannot resolve dynamic method name at compile time.",call.getMethod());
    return;
  }
  if (extension.beforeMethodCall(call)) {
    extension.afterMethodCall(call);
    return;
  }
  typeCheckingContext.pushEnclosingMethodCall(call);
  final Expression objectExpression=call.getObjectExpression();
  objectExpression.visit(this);
  call.getMethod().visit(this);
  if (call.isSpreadSafe()) {
    ClassNode expressionType=getType(objectExpression);
    if (!(expressionType.equals(Collection_TYPE) || expressionType.implementsInterface(Collection_TYPE))) {
      addStaticTypeError("Spread operator can only be used on collection types",expressionType);
      return;
    }
 else {
      ClassNode componentType=inferComponentType(expressionType,int_TYPE);
      MethodCallExpression subcall=new MethodCallExpression(new CastExpression(componentType,EmptyExpression.INSTANCE),name,call.getArguments());
      subcall.setLineNumber(call.getLineNumber());
      subcall.setColumnNumber(call.getColumnNumber());
      visitMethodCallExpression(subcall);
      ClassNode subcallReturnType=getType(subcall);
      ClassNode listNode=LIST_TYPE.getPlainNodeReference();
      listNode.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subcallReturnType))});
      storeType(call,listNode);
      storeTargetMethod(call,(MethodNode)subcall.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET));
      typeCheckingContext.popEnclosingMethodCall();
      return;
    }
  }
  final ClassNode rememberLastItType=typeCheckingContext.lastImplicitItType;
  Expression callArguments=call.getArguments();
  ArgumentListExpression argumentList=InvocationWriter.makeArgumentList(callArguments);
  checkForbiddenSpreadArgument(argumentList);
  boolean isWithCall=isWithCall(name,callArguments);
  visitMethodCallArguments(argumentList,false,null);
  ClassNode[] args=getArgumentTypes(argumentList);
  final boolean isCallOnClosure=isClosureCall(name,objectExpression,callArguments);
  final ClassNode receiver=getType(objectExpression);
  if (isWithCall) {
    typeCheckingContext.lastImplicitItType=receiver;
    checkClosureParameters(callArguments,receiver);
  }
  try {
    if (isCallOnClosure) {
      if (objectExpression == VariableExpression.THIS_EXPRESSION) {
        FieldNode field=typeCheckingContext.getEnclosingClassNode().getDeclaredField(name);
        GenericsType[] genericsTypes=field.getType().getGenericsTypes();
        if (genericsTypes != null) {
          ClassNode closureReturnType=genericsTypes[0].getType();
          Object data=field.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
          if (data != null) {
            Parameter[] parameters=(Parameter[])data;
            typeCheckClosureCall(callArguments,args,parameters);
          }
          storeType(call,closureReturnType);
        }
      }
 else       if (objectExpression instanceof VariableExpression) {
        Variable variable=findTargetVariable((VariableExpression)objectExpression);
        if (variable instanceof ASTNode) {
          Object data=((ASTNode)variable).getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
          if (data != null) {
            Parameter[] parameters=(Parameter[])data;
            typeCheckClosureCall(callArguments,args,parameters);
          }
          Object type=((ASTNode)variable).getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);
          if (type == null) {
            if (variable.getType().equals(CLOSURE_TYPE)) {
              GenericsType[] genericsTypes=variable.getType().getGenericsTypes();
              if (genericsTypes != null && !genericsTypes[0].isPlaceholder()) {
                type=genericsTypes[0].getType();
              }
 else {
                type=OBJECT_TYPE;
              }
            }
          }
          if (type != null) {
            storeType(call,(ClassNode)type);
          }
        }
      }
 else       if (objectExpression instanceof ClosureExpression) {
        Parameter[] parameters=((ClosureExpression)objectExpression).getParameters();
        typeCheckClosureCall(callArguments,args,parameters);
        Object data=objectExpression.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);
        if (data != null) {
          storeType(call,(ClassNode)data);
        }
      }
      int nbOfArgs=0;
      if (callArguments instanceof ArgumentListExpression) {
        ArgumentListExpression list=(ArgumentListExpression)callArguments;
        nbOfArgs=list.getExpressions().size();
      }
 else {
        nbOfArgs=0;
      }
      storeTargetMethod(call,nbOfArgs == 0 ? CLOSURE_CALL_NO_ARG : nbOfArgs == 1 ? CLOSURE_CALL_ONE_ARG : CLOSURE_CALL_VARGS);
    }
 else {
      List<Receiver<String>> receivers=new LinkedList<Receiver<String>>();
      List<Receiver<String>> owners=makeOwnerList(objectExpression);
      addReceivers(receivers,owners,call.isImplicitThis());
      List<MethodNode> mn=null;
      Receiver<String> chosenReceiver=null;
      for (      Receiver<String> currentReceiver : receivers) {
        mn=findMethod(currentReceiver.getType(),name,args);
        if (!mn.isEmpty() && typeCheckingContext.isInStaticContext && (call.isImplicitThis() || (objectExpression instanceof VariableExpression && ((VariableExpression)objectExpression).isThisExpression()))) {
          List<MethodNode> staticMethods=new LinkedList<MethodNode>();
          List<MethodNode> nonStaticMethods=new LinkedList<MethodNode>();
          for (          final MethodNode node : mn) {
            if (node.isStatic()) {
              staticMethods.add(node);
            }
 else {
              nonStaticMethods.add(node);
            }
          }
          mn=staticMethods;
          if (staticMethods.isEmpty()) {
            MethodNode node=nonStaticMethods.get(0);
            ClassNode owner=node.getDeclaringClass();
            addStaticTypeError("Non static method " + owner.getName() + "#"+ node.getName()+ " cannot be called from static context",call);
          }
        }
        if (!mn.isEmpty()) {
          if (mn.size() == 1)           typeCheckMethodsWithGenerics(currentReceiver.getType(),args,mn.get(0),call);
          chosenReceiver=currentReceiver;
          break;
        }
      }
      if (mn.isEmpty() && typeCheckingContext.getEnclosingClosure() != null && args.length == 0) {
        if ("getDelegate".equals(name)) {
          mn=Collections.singletonList(GET_DELEGATE);
        }
 else         if ("getOwner".equals(name)) {
          mn=Collections.singletonList(GET_OWNER);
        }
 else         if ("getThisObject".equals(name)) {
          mn=Collections.singletonList(GET_THISOBJECT);
        }
      }
      if (mn.isEmpty()) {
        mn=extension.handleMissingMethod(receiver,name,argumentList,args,call);
      }
      if (mn.isEmpty()) {
        addNoMatchingMethodError(receiver,name,args,call);
      }
 else {
        if (areCategoryMethodCalls(mn,name,args)) {
          addCategoryMethodCallError(call);
        }
        if (mn.size() == 1) {
          MethodNode directMethodCallCandidate=mn.get(0);
          typeCheckingContext.pushEnclosingClassNode(directMethodCallCandidate.getDeclaringClass());
          for (          ClassNode node : typeCheckingContext.source.getAST().getClasses()) {
            if (isClassInnerClassOrEqualTo(typeCheckingContext.getEnclosingClassNode(),node)) {
              silentlyVisitMethodNode(directMethodCallCandidate);
              break;
            }
          }
          pickInferredTypeFromMethodAnnotation(directMethodCallCandidate);
          typeCheckingContext.popEnclosingClassNode();
          ClassNode returnType=getType(directMethodCallCandidate);
          if (isUsingGenericsOrIsArrayUsingGenerics(returnType)) {
            ClassNode irtg=inferReturnTypeGenerics(chosenReceiver.getType(),directMethodCallCandidate,callArguments);
            returnType=irtg != null && implementsInterfaceOrIsSubclassOf(irtg,returnType) ? irtg : returnType;
          }
          storeType(call,returnType);
          storeTargetMethod(call,directMethodCallCandidate);
          String data=chosenReceiver != null ? chosenReceiver.getData() : null;
          if (data != null) {
            call.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER,data);
          }
          if (objectExpression instanceof VariableExpression) {
            VariableExpression var=(VariableExpression)objectExpression;
            if (var.isClosureSharedVariable()) {
              SecondPassExpression<ClassNode[]> wrapper=new SecondPassExpression<ClassNode[]>(call,args);
              typeCheckingContext.secondPassExpressions.add(wrapper);
            }
          }
        }
 else {
          addAmbiguousErrorMessage(mn,name,args,call);
        }
      }
    }
    visitMethodCallArguments(argumentList,true,(MethodNode)call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET));
  }
  finally {
    if (isWithCall) {
      typeCheckingContext.lastImplicitItType=rememberLastItType;
    }
    typeCheckingContext.popEnclosingMethodCall();
    extension.afterMethodCall(call);
  }
}
