{
  final String name=call.getMethodAsString();
  if (name == null) {
    addStaticTypeError("cannot resolve dynamic method name at compile time.",call.getMethod());
    return;
  }
  final Expression objectExpression=call.getObjectExpression();
  objectExpression.visit(this);
  call.getMethod().visit(this);
  if (call.isSpreadSafe()) {
    ClassNode expressionType=getType(objectExpression);
    if (!(expressionType.equals(Collection_TYPE) || expressionType.implementsInterface(Collection_TYPE))) {
      addStaticTypeError("Spread operator can only be used on collection types",expressionType);
      return;
    }
 else {
      ClassNode componentType=inferComponentType(expressionType);
      MethodCallExpression subcall=new MethodCallExpression(new CastExpression(componentType,EmptyExpression.INSTANCE),name,call.getArguments());
      subcall.setLineNumber(call.getLineNumber());
      subcall.setColumnNumber(call.getColumnNumber());
      visitMethodCallExpression(subcall);
      ClassNode subcallReturnType=getType(subcall);
      ClassNode listNode=new ClassNode(List.class);
      listNode.setGenericsTypes(new GenericsType[]{new GenericsType(subcallReturnType)});
      storeType(call,listNode);
      return;
    }
  }
  final ClassNode rememberLastItType=lastImplicitItType;
  Expression callArguments=call.getArguments();
  boolean isWithCall=isWithCall(name,callArguments);
  if (!isWithCall) {
    callArguments.visit(this);
  }
  ClassNode[] args=getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));
  final boolean isCallOnClosure=isClosureCall(name,objectExpression);
  final ClassNode receiver=getType(objectExpression);
  if (isWithCall) {
    withReceiverList.add(0,receiver);
    lastImplicitItType=receiver;
    if (callArguments instanceof ArgumentListExpression) {
      ArgumentListExpression argList=(ArgumentListExpression)callArguments;
      ClosureExpression closure=(ClosureExpression)argList.getExpression(0);
      Parameter[] parameters=closure.getParameters();
      if (parameters.length > 1) {
        addStaticTypeError("Unexpected number of parameters for a with call",argList);
      }
 else       if (parameters.length == 1) {
        Parameter param=parameters[0];
        if (!param.isDynamicTyped() && !isAssignableTo(receiver,param.getType().redirect())) {
          addStaticTypeError("Expected parameter type: " + receiver.toString(false) + " but was: "+ param.getType().redirect().toString(false),param);
        }
      }
    }
  }
  try {
    if (isWithCall) {
      callArguments.visit(this);
    }
    List<ClassNode> receivers=new LinkedList<ClassNode>();
    if (!withReceiverList.isEmpty())     receivers.addAll(withReceiverList);
    receivers.add(receiver);
    if (!temporaryIfBranchTypeInformation.empty()) {
      final Map<Object,List<ClassNode>> tempo=temporaryIfBranchTypeInformation.peek();
      Object key=extractTemporaryTypeInfoKey(objectExpression);
      List<ClassNode> potentialReceiverType=tempo.get(key);
      if (potentialReceiverType != null)       receivers.addAll(potentialReceiverType);
    }
    List<MethodNode> mn=null;
    ClassNode chosenReceiver=null;
    for (    ClassNode currentReceiver : receivers) {
      mn=findMethod(currentReceiver,name,args);
      if (!mn.isEmpty()) {
        typeCheckMethodsWithGenerics(currentReceiver,args,mn,call);
        chosenReceiver=currentReceiver;
        break;
      }
    }
    if (mn.isEmpty()) {
      addStaticTypeError("Cannot find matching method " + receiver.getName() + "#"+ toMethodParametersString(name,args),call);
    }
 else {
      if (isCallOnClosure) {
        if (objectExpression instanceof VariableExpression) {
          Variable variable=findTargetVariable((VariableExpression)objectExpression);
          if (variable instanceof Expression) {
            Object data=((Expression)variable).getNodeMetaData(StaticTypesTransformation.StaticTypesMarker.CLOSURE_ARGUMENTS);
            if (data != null) {
              Parameter[] parameters=(Parameter[])data;
              typeCheckClosureCall(callArguments,args,parameters);
            }
            Object type=((Expression)variable).getNodeMetaData(StaticTypesTransformation.StaticTypesMarker.CLOSURE_INFERRED_RETURN_TYPE);
            if (type != null) {
              storeType(call,(ClassNode)type);
            }
          }
        }
 else         if (objectExpression instanceof ClosureExpression) {
          Parameter[] parameters=((ClosureExpression)objectExpression).getParameters();
          typeCheckClosureCall(callArguments,args,parameters);
          Object data=objectExpression.getNodeMetaData(StaticTypesTransformation.StaticTypesMarker.CLOSURE_INFERRED_RETURN_TYPE);
          if (data != null) {
            storeType(call,(ClassNode)data);
          }
        }
      }
 else {
        if (mn.size() == 1) {
          MethodNode directMethodCallCandidate=mn.get(0);
          ClassNode returnType=directMethodCallCandidate.getReturnType();
          if (returnType.isUsingGenerics()) {
            returnType=inferReturnTypeGenerics(chosenReceiver,directMethodCallCandidate,callArguments);
          }
          storeType(call,returnType);
          storeTargetMethod(call,directMethodCallCandidate);
        }
 else {
          addStaticTypeError("Reference to method is ambiguous. Cannot choose between " + mn,call);
        }
      }
    }
  }
  finally {
    if (isWithCall) {
      lastImplicitItType=rememberLastItType;
      withReceiverList.removeFirst();
    }
  }
}
