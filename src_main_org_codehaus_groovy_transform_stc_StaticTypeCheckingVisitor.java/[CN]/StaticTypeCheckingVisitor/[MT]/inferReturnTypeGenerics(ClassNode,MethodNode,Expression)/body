{
  ClassNode returnType=method.getReturnType();
  if (method instanceof ExtensionMethodNode && (isUsingGenericsOrIsArrayUsingGenerics(returnType))) {
    ExtensionMethodNode emn=(ExtensionMethodNode)method;
    MethodNode dgmMethod=emn.getExtensionMethodNode();
    ClassNode dc=emn.getDeclaringClass();
    ArgumentListExpression argList=new ArgumentListExpression();
    VariableExpression vexp=new VariableExpression("$foo",receiver);
    vexp.setNodeMetaData(ExtensionMethodDeclaringClass.class,dc);
    argList.addExpression(vexp);
    if (arguments instanceof ArgumentListExpression) {
      List<Expression> expressions=((ArgumentListExpression)arguments).getExpressions();
      for (      Expression arg : expressions) {
        argList.addExpression(arg);
      }
    }
 else {
      argList.addExpression(arguments);
    }
    return inferReturnTypeGenerics(dc,dgmMethod,argList);
  }
  if (!isUsingGenericsOrIsArrayUsingGenerics(returnType))   return returnType;
  if (getGenericsWithoutArray(returnType) == null)   return returnType;
  Map<String,GenericsType> resolvedPlaceholders=resolvePlaceHoldersFromDeclartion(receiver,getDeclaringClass(method,arguments),method,method.isStatic());
  if (resolvedPlaceholders.isEmpty())   return returnType;
  Parameter[] parameters=method.getParameters();
  boolean isVargs=isVargs(parameters);
  ArgumentListExpression argList=InvocationWriter.makeArgumentList(arguments);
  List<Expression> expressions=argList.getExpressions();
  int paramLength=parameters.length;
  if (expressions.size() >= paramLength) {
    for (int i=0; i < paramLength; i++) {
      boolean lastArg=i == paramLength - 1;
      ClassNode type=parameters[i].getType();
      if (!type.isUsingGenerics() && type.isArray())       type=type.getComponentType();
      if (type.isUsingGenerics()) {
        ClassNode actualType=getType(expressions.get(i));
        if (isVargs && lastArg && actualType.isArray()) {
          actualType=actualType.getComponentType();
        }
        actualType=wrapTypeIfNecessary(actualType);
        Map<String,GenericsType> typePlaceholders=GenericsUtils.extractPlaceholders(type);
        if (OBJECT_TYPE.equals(type)) {
          for (          String key : typePlaceholders.keySet()) {
            resolvedPlaceholders.put(key,new GenericsType(actualType.isArray() ? actualType.getComponentType() : actualType));
          }
        }
 else {
          while (actualType != null && !actualType.equals(type)) {
            Set<ClassNode> interfaces=actualType.getAllInterfaces();
            boolean intf=false;
            for (            ClassNode anInterface : interfaces) {
              if (anInterface.equals(type)) {
                intf=true;
                actualType=GenericsUtils.parameterizeType(actualType,anInterface);
                break;
              }
            }
            if (!intf)             actualType=actualType.getUnresolvedSuperClass();
          }
          if (actualType != null) {
            Map<String,GenericsType> actualTypePlaceholders=GenericsUtils.extractPlaceholders(actualType);
            for (            Map.Entry<String,GenericsType> typeEntry : actualTypePlaceholders.entrySet()) {
              String key=typeEntry.getKey();
              GenericsType value=typeEntry.getValue();
              GenericsType alias=typePlaceholders.get(key);
              if (alias != null && alias.isPlaceholder()) {
                resolvedPlaceholders.put(alias.getName(),value);
              }
            }
          }
        }
      }
    }
  }
  return resolveGenericsWithContext(resolvedPlaceholders,returnType);
}
