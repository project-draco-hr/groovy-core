{
  ClassNode returnType=method.getReturnType();
  GenericsType[] returnTypeGenerics=returnType.getGenericsTypes();
  List<GenericsType> placeholders=new LinkedList<GenericsType>();
  for (  GenericsType returnTypeGeneric : returnTypeGenerics) {
    if (returnTypeGeneric.isPlaceholder() || returnTypeGeneric.isWildcard()) {
      placeholders.add(returnTypeGeneric);
    }
  }
  if (placeholders.isEmpty())   return returnType;
  Map<String,ClassNode> resolvedPlaceholders=new HashMap<String,ClassNode>();
  if (receiver.isUsingGenerics()) {
    ClassNode redirect=receiver.redirect();
    GenericsType[] redirectGenericsType=redirect.getGenericsTypes();
    GenericsType[] receiverGenericsTypes=receiver.getGenericsTypes();
    for (int i=0; i < receiverGenericsTypes.length; i++) {
      if (redirectGenericsType[i].isPlaceholder() || redirectGenericsType[i].isWildcard()) {
        String name=redirectGenericsType[i].getName();
        resolvedPlaceholders.put(name,receiverGenericsTypes[i].getType());
      }
    }
  }
  Parameter[] parameters=method.getParameters();
  boolean isVargs=isVargs(parameters);
  ArgumentListExpression argList=InvocationWriter.makeArgumentList(arguments);
  List<Expression> expressions=argList.getExpressions();
  int paramLength=parameters.length;
  for (int i=0; i < paramLength; i++) {
    boolean lastArg=i == paramLength - 1;
    ClassNode type=parameters[i].getType();
    if (!type.isUsingGenerics() && type.isArray())     type=type.getComponentType();
    if (type.isUsingGenerics()) {
      GenericsType[] genericsTypes=type.getGenericsTypes();
      for (      GenericsType genericsType : genericsTypes) {
        if (genericsType.isPlaceholder() || genericsType.isWildcard()) {
          ClassNode actualType=getType(expressions.get(i));
          if (isVargs && lastArg && actualType.isArray()) {
            actualType=actualType.getComponentType();
          }
          resolvedPlaceholders.put(genericsType.getName(),actualType);
        }
      }
    }
  }
  GenericsType[] copy=new GenericsType[returnTypeGenerics.length];
  for (int i=0; i < copy.length; i++) {
    GenericsType returnTypeGeneric=returnTypeGenerics[i];
    if (returnTypeGeneric.isPlaceholder() || returnTypeGeneric.isWildcard()) {
      ClassNode resolved=resolvedPlaceholders.get(returnTypeGeneric.getName());
      if (resolved == null)       resolved=returnTypeGeneric.getType();
      copy[i]=new GenericsType(resolved);
    }
 else {
      copy[i]=returnTypeGeneric;
    }
  }
  if (returnType.equals(OBJECT_TYPE)) {
    return copy[0].getType();
  }
  returnType=returnType.getPlainNodeReference();
  returnType.setGenericsTypes(copy);
  return returnType;
}
