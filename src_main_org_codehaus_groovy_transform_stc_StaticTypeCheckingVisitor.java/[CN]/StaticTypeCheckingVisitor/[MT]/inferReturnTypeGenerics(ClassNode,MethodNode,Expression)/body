{
  ClassNode returnType=method.getReturnType();
  if (method instanceof ExtensionMethodNode && (returnType.isGenericsPlaceHolder() || returnType.isArray() && returnType.getComponentType().isGenericsPlaceHolder())) {
    ExtensionMethodNode emn=(ExtensionMethodNode)method;
    MethodNode dgmMethod=emn.getExtensionMethodNode();
    ClassNode firstParam=dgmMethod.getParameters()[0].getOriginType();
    if (firstParam.isGenericsPlaceHolder() || firstParam.isArray() && firstParam.getComponentType().isGenericsPlaceHolder()) {
      ClassNode paramType=firstParam.isArray() ? firstParam.getComponentType() : firstParam;
      ClassNode returnTypeComp=returnType.isArray() ? returnType.getComponentType() : returnType;
      if (paramType.getName().equals(returnTypeComp.getName())) {
        return returnType.isArray() ? receiver : receiver.getComponentType();
      }
    }
  }
  if (!returnType.isUsingGenerics())   return returnType;
  GenericsType[] returnTypeGenerics=returnType.getGenericsTypes();
  List<GenericsType> placeholders=new LinkedList<GenericsType>();
  for (  GenericsType returnTypeGeneric : returnTypeGenerics) {
    if (returnTypeGeneric.isPlaceholder() || returnTypeGeneric.isWildcard()) {
      placeholders.add(returnTypeGeneric);
    }
  }
  if (placeholders.isEmpty())   return returnType;
  Map<String,GenericsType> resolvedPlaceholders=new HashMap<String,GenericsType>();
  GenericsUtils.extractPlaceholders(receiver,resolvedPlaceholders);
  GenericsUtils.extractPlaceholders(method.getReturnType(),resolvedPlaceholders);
  Parameter[] parameters=method.getParameters();
  boolean isVargs=isVargs(parameters);
  ArgumentListExpression argList=InvocationWriter.makeArgumentList(arguments);
  List<Expression> expressions=argList.getExpressions();
  int paramLength=parameters.length;
  for (int i=0; i < paramLength; i++) {
    boolean lastArg=i == paramLength - 1;
    ClassNode type=parameters[i].getType();
    if (!type.isUsingGenerics() && type.isArray())     type=type.getComponentType();
    if (type.isUsingGenerics()) {
      ClassNode actualType=getType(expressions.get(i));
      if (isVargs && lastArg && actualType.isArray()) {
        actualType=actualType.getComponentType();
      }
      actualType=wrapTypeIfNecessary(actualType);
      Map<String,GenericsType> typePlaceholders=GenericsUtils.extractPlaceholders(type.isArray() ? type.getComponentType() : type);
      if (OBJECT_TYPE.equals(type)) {
        for (        String key : typePlaceholders.keySet()) {
          resolvedPlaceholders.put(key,new GenericsType(actualType));
        }
      }
 else {
        while (!actualType.equals(type)) {
          Set<ClassNode> interfaces=actualType.getAllInterfaces();
          boolean intf=false;
          for (          ClassNode anInterface : interfaces) {
            if (anInterface.equals(type)) {
              intf=true;
              actualType=GenericsUtils.parameterizeInterfaceGenerics(actualType,anInterface);
            }
          }
          if (!intf)           actualType=actualType.getUnresolvedSuperClass();
        }
        Map<String,GenericsType> actualTypePlaceholders=GenericsUtils.extractPlaceholders(actualType);
        for (        Map.Entry<String,GenericsType> typeEntry : actualTypePlaceholders.entrySet()) {
          String key=typeEntry.getKey();
          GenericsType value=typeEntry.getValue();
          GenericsType alias=typePlaceholders.get(key);
          if (alias != null && alias.isPlaceholder()) {
            resolvedPlaceholders.put(alias.getName(),value);
          }
        }
      }
    }
  }
  GenericsType[] copy=new GenericsType[returnTypeGenerics.length];
  for (int i=0; i < copy.length; i++) {
    GenericsType returnTypeGeneric=returnTypeGenerics[i];
    if (returnTypeGeneric.isPlaceholder() || returnTypeGeneric.isWildcard()) {
      GenericsType resolved=resolvedPlaceholders.get(returnTypeGeneric.getName());
      if (resolved == null)       resolved=returnTypeGeneric;
      copy[i]=resolved;
    }
 else {
      copy[i]=returnTypeGeneric;
    }
  }
  if (returnType.equals(OBJECT_TYPE)) {
    return copy[0].getType();
  }
  returnType=returnType.getPlainNodeReference();
  returnType.setGenericsTypes(copy);
  if (returnType.equals(Annotation_TYPE) && returnType.getGenericsTypes() != null && !returnType.getGenericsTypes()[0].isPlaceholder()) {
    return returnType.getGenericsTypes()[0].getType();
  }
  return returnType;
}
