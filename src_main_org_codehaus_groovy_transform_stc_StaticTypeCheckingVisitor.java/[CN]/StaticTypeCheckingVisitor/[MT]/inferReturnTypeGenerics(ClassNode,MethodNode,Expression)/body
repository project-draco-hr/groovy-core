{
  ClassNode returnType=method.getReturnType();
  if (method instanceof ExtensionMethodNode && (isUsingGenericsOrIsArrayUsingGenerics(returnType))) {
    ExtensionMethodNode emn=(ExtensionMethodNode)method;
    MethodNode dgmMethod=emn.getExtensionMethodNode();
    ClassNode dc=emn.getDeclaringClass();
    ArgumentListExpression argList=new ArgumentListExpression();
    VariableExpression vexp=new VariableExpression("$foo",receiver);
    vexp.setNodeMetaData(ExtensionMethodDeclaringClass.class,dc);
    argList.addExpression(vexp);
    if (arguments instanceof ArgumentListExpression) {
      List<Expression> expressions=((ArgumentListExpression)arguments).getExpressions();
      for (      Expression arg : expressions) {
        argList.addExpression(arg);
      }
    }
 else {
      argList.addExpression(arguments);
    }
    return inferReturnTypeGenerics(dc,dgmMethod,argList);
  }
  if (!isUsingGenericsOrIsArrayUsingGenerics(returnType))   return returnType;
  if (getGenericsWithoutArray(returnType) == null)   return returnType;
  Map<String,GenericsType> resolvedPlaceholders=resolvePlaceHolders(receiver,method,arguments);
  if (resolvedPlaceholders.isEmpty())   return returnType;
  Parameter[] parameters=method.getParameters();
  boolean isVargs=isVargs(parameters);
  ArgumentListExpression argList=InvocationWriter.makeArgumentList(arguments);
  List<Expression> expressions=argList.getExpressions();
  int paramLength=parameters.length;
  if (expressions.size() >= paramLength) {
    for (int i=0; i < paramLength; i++) {
      boolean lastArg=i == paramLength - 1;
      ClassNode type=parameters[i].getType();
      if (!type.isUsingGenerics() && type.isArray())       type=type.getComponentType();
      if (type.isUsingGenerics()) {
        ClassNode actualType=getType(expressions.get(i));
        if (isVargs && lastArg && actualType.isArray()) {
          actualType=actualType.getComponentType();
        }
        actualType=wrapTypeIfNecessary(actualType);
        Map<String,GenericsType> typePlaceholders=GenericsUtils.extractPlaceholders(type);
        if (OBJECT_TYPE.equals(type)) {
          for (          String key : typePlaceholders.keySet()) {
            resolvedPlaceholders.put(key,new GenericsType(actualType.isArray() ? actualType.getComponentType() : actualType));
          }
        }
 else {
          while (actualType != null && !actualType.equals(type)) {
            Set<ClassNode> interfaces=actualType.getAllInterfaces();
            boolean intf=false;
            for (            ClassNode anInterface : interfaces) {
              if (anInterface.equals(type)) {
                intf=true;
                actualType=GenericsUtils.parameterizeType(actualType,anInterface);
                break;
              }
            }
            if (!intf)             actualType=actualType.getUnresolvedSuperClass();
          }
          if (actualType != null) {
            Map<String,GenericsType> actualTypePlaceholders=GenericsUtils.extractPlaceholders(actualType);
            for (            Map.Entry<String,GenericsType> typeEntry : actualTypePlaceholders.entrySet()) {
              String key=typeEntry.getKey();
              GenericsType value=typeEntry.getValue();
              GenericsType alias=typePlaceholders.get(key);
              if (alias != null && alias.isPlaceholder()) {
                resolvedPlaceholders.put(alias.getName(),value);
              }
            }
          }
        }
      }
    }
  }
  Map<String,GenericsType> placeholdersFromContext=getGenericsParameterMapOfThis(typeCheckingContext.getEnclosingMethod());
  applyContextGenerics(resolvedPlaceholders,placeholdersFromContext);
  returnType=applyGenerics(returnType,resolvedPlaceholders);
  if (returnType.isGenericsPlaceHolder()) {
    GenericsType resolved=resolvedPlaceholders.get(returnType.getUnresolvedName());
    if (resolved != null && !resolved.isPlaceholder() && !resolved.isWildcard()) {
      return resolved.getType();
    }
  }
  GenericsType[] returnTypeGenerics=getGenericsWithoutArray(returnType);
  if (returnTypeGenerics == null)   return returnType;
  GenericsType[] copy=new GenericsType[returnTypeGenerics.length];
  for (int i=0; i < copy.length; i++) {
    GenericsType returnTypeGeneric=returnTypeGenerics[i];
    if (returnTypeGeneric.isPlaceholder() || returnTypeGeneric.isWildcard()) {
      GenericsType resolved=resolvedPlaceholders.get(returnTypeGeneric.getName());
      if (resolved == null)       resolved=returnTypeGeneric;
      copy[i]=fullyResolve(resolved,resolvedPlaceholders);
    }
 else {
      copy[i]=fullyResolve(returnTypeGeneric,resolvedPlaceholders);
    }
  }
  GenericsType firstGenericsType=copy[0];
  if (returnType.equals(OBJECT_TYPE)) {
    if (firstGenericsType.getType().isGenericsPlaceHolder())     return OBJECT_TYPE;
    if (firstGenericsType.isWildcard()) {
      if (firstGenericsType.getLowerBound() != null)       return firstGenericsType.getLowerBound();
      ClassNode[] upperBounds=firstGenericsType.getUpperBounds();
      if (upperBounds == null) {
        return OBJECT_TYPE;
      }
      if (upperBounds.length == 1)       return upperBounds[0];
      return new UnionTypeClassNode(upperBounds);
    }
    return firstGenericsType.getType();
  }
  if (returnType.isArray()) {
    returnType=returnType.getComponentType().getPlainNodeReference();
    returnType.setGenericsTypes(copy);
    if (OBJECT_TYPE.equals(returnType)) {
      returnType=firstGenericsType.getType();
    }
    returnType=returnType.makeArray();
  }
 else {
    returnType=returnType.getPlainNodeReference();
    returnType.setGenericsTypes(copy);
  }
  if (returnType.equals(Annotation_TYPE) && returnType.getGenericsTypes() != null && !returnType.getGenericsTypes()[0].isPlaceholder()) {
    return returnType.getGenericsTypes()[0].getType();
  }
  return returnType;
}
