{
switch (operation.getType()) {
case Types.EQUAL:
    if (!leftExpression.isDynamic())     return leftExpression.getTypeClass();
 else     return rightExpression.getTypeClass();
case Types.COMPARE_IDENTICAL:
case Types.COMPARE_EQUAL:
case Types.COMPARE_NOT_EQUAL:
case Types.COMPARE_GREATER_THAN:
case Types.COMPARE_GREATER_THAN_EQUAL:
case Types.COMPARE_LESS_THAN:
case Types.COMPARE_LESS_THAN_EQUAL:
case Types.KEYWORD_INSTANCEOF:
case Types.MATCH_REGEX:
  return boolean.class;
case Types.LOGICAL_AND:
case Types.LOGICAL_OR:
return Boolean.class;
case Types.COMPARE_TO:
return Integer.class;
case Types.PLUS:
case Types.PLUS_EQUAL:
{
if (leftExpression.getTypeClass() == String.class && rightExpression.getTypeClass() == String.class) {
return String.class;
}
 else if (leftExpression.getTypeClass() == GString.class && (rightExpression.getTypeClass() == GString.class || rightExpression.getTypeClass() == String.class)) {
return GString.class;
}
 else if (isNumber(leftExpression.getType()) && isNumber(rightExpression.getType())) {
return chooseWiderNumberType(leftExpression.getType(),rightExpression.getType());
}
 else if (leftExpression.getTypeClass() == Date.class && Number.class.isAssignableFrom(rightExpression.getTypeClass())) {
return Date.class;
}
 else if (leftExpression.getTypeClass() != null && Collection.class.isAssignableFrom(leftExpression.getTypeClass())) {
return List.class;
}
 else {
return null;
}
}
case Types.MINUS:
case Types.MINUS_EQUAL:
{
if (leftExpression.getTypeClass() == String.class) {
return String.class;
}
 else if (leftExpression instanceof GStringExpression && isNumber(rightExpression.getType())) {
return String.class;
}
 else if (isNumber(leftExpression.getType()) && isNumber(rightExpression.getType())) {
return chooseWiderNumberType(leftExpression.getType(),rightExpression.getType());
}
 else if (leftExpression.getTypeClass() != null && List.class.isAssignableFrom(leftExpression.getTypeClass())) {
return List.class;
}
 else if (leftExpression.getTypeClass() == Date.class && Number.class.isAssignableFrom(rightExpression.getTypeClass())) {
return Date.class;
}
 else {
return null;
}
}
case Types.MULTIPLY:
case Types.MULTIPLY_EQUAL:
{
if (leftExpression.getTypeClass() == String.class && isNumber(rightExpression.getType())) {
return String.class;
}
 else if (leftExpression instanceof GStringExpression && isNumber(rightExpression.getType())) {
return String.class;
}
 else if (isNumber(leftExpression.getType()) && isNumber(rightExpression.getType())) {
return chooseWiderNumberType(leftExpression.getType(),rightExpression.getType());
}
 else if (leftExpression.getTypeClass() != null && Collection.class.isAssignableFrom(leftExpression.getTypeClass())) {
return List.class;
}
 else {
return null;
}
}
case Types.DIVIDE:
case Types.DIVIDE_EQUAL:
case Types.MOD:
case Types.MOD_EQUAL:
if (isNumber(leftExpression.getType()) && isNumber(rightExpression.getType())) {
return chooseWiderNumberType(leftExpression.getType(),rightExpression.getType());
}
return null;
case Types.POWER:
case Types.POWER_EQUAL:
if (isNumber(leftExpression.getType()) && isNumber(rightExpression.getType())) {
return chooseWiderNumberType(leftExpression.getType(),rightExpression.getType());
}
return null;
case Types.LEFT_SHIFT:
if (isNumber(leftExpression.getType()) && isNumber(rightExpression.getType())) {
return leftExpression.getTypeClass();
}
 else if (leftExpression.getTypeClass() != null && Collection.class.isAssignableFrom(leftExpression.getTypeClass())) {
return Collection.class;
}
 else if (leftExpression.getTypeClass() != null && OutputStream.class.isAssignableFrom(leftExpression.getTypeClass())) {
return Writer.class;
}
 else if (leftExpression.getTypeClass() != null && StringBuffer.class.isAssignableFrom(leftExpression.getTypeClass())) {
return Writer.class;
}
return null;
case Types.RIGHT_SHIFT:
case Types.RIGHT_SHIFT_UNSIGNED:
if (isNumber(leftExpression.getType()) && isNumber(rightExpression.getType())) {
return leftExpression.getTypeClass();
}
return null;
case Types.FIND_REGEX:
return Matcher.class;
case Types.LEFT_SQUARE_BRACKET:
Class cls=leftExpression.getTypeClass();
if (cls != null) {
if (cls.isArray()) {
Class elemType=cls.getComponentType();
return elemType;
}
 else if (leftExpression instanceof ListExpression) {
Class elemType=((ListExpression)leftExpression).getComponentTypeClass();
return elemType;
}
 else if (leftExpression instanceof MapExpression) {
return Object.class;
}
 else if (List.class.isAssignableFrom(cls)) {
return (Object.class);
}
 else if (Map.class.isAssignableFrom(cls)) {
return (Object.class);
}
}
break;
}
return null;
}
