{
  BlockStatement initBody=new BlockStatement();
  if (cNode.getDeclaredConstructors().size() == 0) {
    initBody.addStatement(EmptyStatement.INSTANCE);
    cNode.addConstructor(ACC_PUBLIC,Parameter.EMPTY_ARRAY,ClassNode.EMPTY_ARRAY,initBody);
    initBody=new BlockStatement();
  }
  Parameter initParam=new Parameter(GenericsUtils.nonGeneric(cNode),"other");
  final Expression other=var(initParam);
  boolean hasParent=cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;
  if (hasParent) {
    initBody.addStatement(stmt(ctorX(ClassNode.SUPER,other)));
  }
  for (  FieldNode fieldNode : list) {
    String name=fieldNode.getName();
    if (excludes.contains(name))     continue;
    Expression direct=prop(other,name);
    Expression cloned=callX(direct,"clone");
    Expression to=prop(var("this"),name);
    Statement assignCloned=assignS(to,cloned);
    Statement assignDirect=assignS(to,direct);
    initBody.addStatement(ifElseS(isInstanceOf(direct,CLONEABLE_TYPE),assignCloned,assignDirect));
  }
  ClassNode[] exceptions={make(CloneNotSupportedException.class)};
  cNode.addConstructor(ACC_PROTECTED,params(initParam),ClassNode.EMPTY_ARRAY,initBody);
  cNode.addMethod("clone",ACC_PUBLIC,ClassHelper.OBJECT_TYPE,Parameter.EMPTY_ARRAY,exceptions,block(stmt(ctorX(cNode,args(var("this"))))));
}
