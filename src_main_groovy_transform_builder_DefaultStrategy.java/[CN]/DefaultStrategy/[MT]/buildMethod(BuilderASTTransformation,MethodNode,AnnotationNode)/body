{
  if (transform.getMemberValue(anno,"includes") != null || transform.getMemberValue(anno,"includes") != null) {
    transform.addError("Error during " + BuilderASTTransformation.MY_TYPE_NAME + " processing: includes/excludes only allowed on classes",anno);
  }
  String prefix=transform.getMemberStringValue(anno,"prefix","");
  if (unsupportedAttribute(transform,anno,"forClass"))   return;
  final int visibility=ACC_PUBLIC | ACC_STATIC;
  ClassNode buildee=mNode.getDeclaringClass();
  String builderClassName=transform.getMemberStringValue(anno,"builderClassName",buildee.getName() + "Builder");
  final String fullName=buildee.getName() + "$" + builderClassName;
  ClassNode builder=new InnerClassNode(buildee,fullName,visibility,ClassHelper.OBJECT_TYPE);
  buildee.getModule().addClass(builder);
  buildee.addMethod(createBuilderMethod(transform,anno,builder));
  for (  Parameter parameter : mNode.getParameters()) {
    builder.addField(createFieldCopy(buildee,parameter));
    builder.addMethod(createBuilderMethodForProp(builder,new PropertyInfo(parameter.getName(),parameter.getType()),prefix));
  }
  builder.addMethod(createBuildMethodForMethod(transform,anno,buildee,mNode,mNode.getParameters()));
}
