{
  if (nodes.length != 2 || !(nodes[0] instanceof AnnotationNode) || !(nodes[1] instanceof AnnotatedNode)) {
    throw new RuntimeException("Internal error: expecting [AnnotationNode, AnnotatedNode] but got: " + Arrays.asList(nodes));
  }
  AnnotationNode node=(AnnotationNode)nodes[0];
  AnnotatedNode parent=(AnnotatedNode)nodes[1];
  if (!MY_TYPE.equals(node.getClassNode()))   return;
  final Expression expr=node.getMember("value");
  if (expr == null) {
    return;
  }
  Expression useClasses=null;
  if (expr instanceof ClassExpression) {
    useClasses=expr;
  }
 else   if (expr instanceof ListExpression) {
    ListExpression listExpression=(ListExpression)expr;
    for (    Expression ex : listExpression.getExpressions()) {
      if (!(ex instanceof ClassExpression))       return;
    }
    useClasses=expr;
  }
  if (useClasses == null)   return;
  if (parent instanceof ClassNode) {
    ClassNode annotatedClass=(ClassNode)parent;
    final Parameter[] noparams=new Parameter[0];
    MethodNode clinit=annotatedClass.getDeclaredMethod("<clinit>",noparams);
    if (clinit == null) {
      clinit=annotatedClass.addMethod("<clinit>",Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC,ClassHelper.VOID_TYPE,noparams,null,new BlockStatement());
      clinit.setSynthetic(true);
    }
    final BlockStatement code=(BlockStatement)clinit.getCode();
    code.addStatement(new ExpressionStatement(new MethodCallExpression(new PropertyExpression(new ClassExpression(annotatedClass),"metaClass"),"mixin",useClasses)));
  }
}
