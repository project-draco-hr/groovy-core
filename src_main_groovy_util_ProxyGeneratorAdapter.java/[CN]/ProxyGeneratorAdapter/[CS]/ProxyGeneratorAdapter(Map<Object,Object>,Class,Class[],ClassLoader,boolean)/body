{
  super(new ClassWriter(0));
  this.visitedMethods=new LinkedHashSet<Object>();
  this.delegatedClosures=closureMap.isEmpty() ? EMPTY_DELEGATECLOSURE_MAP : new HashMap<String,Boolean>();
  boolean wildcard=false;
  for (  Map.Entry<Object,Object> entry : closureMap.entrySet()) {
    String name=entry.getKey().toString();
    if ("*".equals(name)) {
      wildcard=true;
    }
    this.delegatedClosures.put(name,Boolean.FALSE);
  }
  this.hasWildcard=wildcard;
  boolean isSuperClassAnInterface=superClass.isInterface();
  this.superClass=isSuperClassAnInterface ? Object.class : superClass;
  this.classList=new LinkedList<Class>();
  this.classList.add(superClass);
  if (interfaces != null) {
    Collections.addAll(this.classList,interfaces);
  }
  this.proxyName=proxyName(superClass.getSimpleName());
  this.loader=proxyLoader != null ? new InnerLoader(proxyLoader) : findClassLoader(superClass);
  this.emptyBody=emptyBody;
  ClassWriter writer=(ClassWriter)cv;
  ClassReader cr=createClassVisitor(Object.class);
  cr.accept(this,0);
  byte[] b=writer.toByteArray();
  cachedClass=loader.defineClass(proxyName,b);
  Class[] args=new Class[]{Map.class};
  Constructor constructor;
  try {
    constructor=cachedClass.getConstructor(args);
  }
 catch (  NoSuchMethodException e) {
    constructor=null;
  }
  cachedNoArgConstructor=constructor;
}
