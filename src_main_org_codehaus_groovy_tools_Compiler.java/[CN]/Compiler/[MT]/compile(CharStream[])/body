{
  CompilationFailuresException failures=new CompilationFailuresException();
  String[] descriptors=new String[sources.length];
  for (int i=0; i < sources.length; ++i) {
    descriptors[i]=sources[i].getDescription();
    if (descriptors[i] == null) {
      descriptors[i]="unknown" + i;
    }
  }
  CSTNode[] csts=new CSTNode[sources.length];
  for (int i=0; i < sources.length; ++i) {
    try {
      csts[i]=parseSource(sources[i],descriptors[i]);
    }
 catch (    ExceptionCollector e) {
      if (!e.isEmpty()) {
        failures.add(descriptors[i],e);
      }
      if (failures.total() > maximumFailuresPerCompile) {
        throw failures;
      }
    }
 finally {
      try {
        sources[i].close();
      }
 catch (      Exception e) {
      }
    }
  }
  if (!failures.isEmpty()) {
    throw failures;
  }
  CompileUnit unit=new CompileUnit();
  ArrayList classes=new ArrayList();
  for (int i=0; i < csts.length; ++i) {
    try {
      ModuleNode ast=buildAST(csts[i],descriptors[i]);
      unit.addModule(ast);
    }
 catch (    ExceptionCollector e) {
      if (!e.isEmpty()) {
        failures.add(descriptors[i],e);
      }
    }
  }
  for (Iterator iter=unit.getModules().iterator(); iter.hasNext(); ) {
    ModuleNode module=(ModuleNode)iter.next();
    try {
      Iterator classNodes=module.getClasses().iterator();
      while (classNodes.hasNext()) {
        ClassNode classNode=(ClassNode)classNodes.next();
        if (verbose) {
          System.out.println("Generating class: " + classNode.getName());
        }
        classes.addAll(generateClasses(new GeneratorContext(unit),classNode,module.getDescription()));
      }
    }
 catch (    ExceptionCollector e) {
      if (!e.isEmpty()) {
        failures.add(module.getDescription(),e);
      }
    }
  }
  if (!failures.isEmpty()) {
    throw failures;
  }
  return (GroovyClass[])classes.toArray(GroovyClass.EMPTY_ARRAY);
}
