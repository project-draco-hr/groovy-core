{
  int type=node.getType();
switch (type) {
case EXPR:
    return expression(node.getFirstChild());
case ELIST:
  return expressionList(node);
case SLIST:
return blockExpression(node);
case CLOSABLE_BLOCK:
return closureExpression(node);
case SUPER_CTOR_CALL:
return specialConstructorCallExpression(node,ClassNode.SUPER);
case METHOD_CALL:
return methodCallExpression(node);
case LITERAL_new:
return constructorCallExpression(node);
case CTOR_CALL:
return specialConstructorCallExpression(node,ClassNode.THIS);
case QUESTION:
case ELVIS_OPERATOR:
return ternaryExpression(node);
case OPTIONAL_DOT:
case SPREAD_DOT:
case DOT:
return dotExpression(node);
case IDENT:
case LITERAL_boolean:
case LITERAL_byte:
case LITERAL_char:
case LITERAL_double:
case LITERAL_float:
case LITERAL_int:
case LITERAL_long:
case LITERAL_short:
case LITERAL_void:
case LITERAL_this:
case LITERAL_super:
return variableExpression(node);
case LIST_CONSTRUCTOR:
return listExpression(node);
case MAP_CONSTRUCTOR:
return mapExpression(node);
case LABELED_ARG:
return mapEntryExpression(node);
case SPREAD_ARG:
return spreadExpression(node);
case SPREAD_MAP_ARG:
return spreadMapExpression(node);
case MEMBER_POINTER:
return methodPointerExpression(node);
case INDEX_OP:
return indexExpression(node);
case LITERAL_instanceof:
return instanceofExpression(node);
case LITERAL_as:
return asExpression(node);
case TYPECAST:
return castExpression(node);
case LITERAL_true:
return literalExpression(node,Boolean.TRUE);
case LITERAL_false:
return literalExpression(node,Boolean.FALSE);
case LITERAL_null:
return literalExpression(node,null);
case STRING_LITERAL:
return literalExpression(node,node.getText());
case STRING_CONSTRUCTOR:
return gstring(node);
case NUM_DOUBLE:
case NUM_FLOAT:
case NUM_BIG_DECIMAL:
return decimalExpression(node);
case NUM_BIG_INT:
case NUM_INT:
case NUM_LONG:
return integerExpression(node);
case LNOT:
NotExpression notExpression=new NotExpression(expression(node.getFirstChild()));
configureAST(notExpression,node);
return notExpression;
case UNARY_MINUS:
return unaryMinusExpression(node);
case BNOT:
BitwiseNegationExpression bitwiseNegationExpression=new BitwiseNegationExpression(expression(node.getFirstChild()));
configureAST(bitwiseNegationExpression,node);
return bitwiseNegationExpression;
case UNARY_PLUS:
return unaryPlusExpression(node);
case INC:
return prefixExpression(node,Types.PLUS_PLUS);
case DEC:
return prefixExpression(node,Types.MINUS_MINUS);
case POST_INC:
return postfixExpression(node,Types.PLUS_PLUS);
case POST_DEC:
return postfixExpression(node,Types.MINUS_MINUS);
case ASSIGN:
return binaryExpression(Types.ASSIGN,node);
case EQUAL:
return binaryExpression(Types.COMPARE_EQUAL,node);
case NOT_EQUAL:
return binaryExpression(Types.COMPARE_NOT_EQUAL,node);
case COMPARE_TO:
return binaryExpression(Types.COMPARE_TO,node);
case LE:
return binaryExpression(Types.COMPARE_LESS_THAN_EQUAL,node);
case LT:
return binaryExpression(Types.COMPARE_LESS_THAN,node);
case GT:
return binaryExpression(Types.COMPARE_GREATER_THAN,node);
case GE:
return binaryExpression(Types.COMPARE_GREATER_THAN_EQUAL,node);
case LAND:
return binaryExpression(Types.LOGICAL_AND,node);
case LOR:
return binaryExpression(Types.LOGICAL_OR,node);
case BAND:
return binaryExpression(Types.BITWISE_AND,node);
case BAND_ASSIGN:
return binaryExpression(Types.BITWISE_AND_EQUAL,node);
case BOR:
return binaryExpression(Types.BITWISE_OR,node);
case BOR_ASSIGN:
return binaryExpression(Types.BITWISE_OR_EQUAL,node);
case BXOR:
return binaryExpression(Types.BITWISE_XOR,node);
case BXOR_ASSIGN:
return binaryExpression(Types.BITWISE_XOR_EQUAL,node);
case PLUS:
return binaryExpression(Types.PLUS,node);
case PLUS_ASSIGN:
return binaryExpression(Types.PLUS_EQUAL,node);
case MINUS:
return binaryExpression(Types.MINUS,node);
case MINUS_ASSIGN:
return binaryExpression(Types.MINUS_EQUAL,node);
case STAR:
return binaryExpression(Types.MULTIPLY,node);
case STAR_ASSIGN:
return binaryExpression(Types.MULTIPLY_EQUAL,node);
case STAR_STAR:
return binaryExpression(Types.POWER,node);
case STAR_STAR_ASSIGN:
return binaryExpression(Types.POWER_EQUAL,node);
case DIV:
return binaryExpression(Types.DIVIDE,node);
case DIV_ASSIGN:
return binaryExpression(Types.DIVIDE_EQUAL,node);
case MOD:
return binaryExpression(Types.MOD,node);
case MOD_ASSIGN:
return binaryExpression(Types.MOD_EQUAL,node);
case SL:
return binaryExpression(Types.LEFT_SHIFT,node);
case SL_ASSIGN:
return binaryExpression(Types.LEFT_SHIFT_EQUAL,node);
case SR:
return binaryExpression(Types.RIGHT_SHIFT,node);
case SR_ASSIGN:
return binaryExpression(Types.RIGHT_SHIFT_EQUAL,node);
case BSR:
return binaryExpression(Types.RIGHT_SHIFT_UNSIGNED,node);
case BSR_ASSIGN:
return binaryExpression(Types.RIGHT_SHIFT_UNSIGNED_EQUAL,node);
case VARIABLE_DEF:
return declarationExpression(node);
case REGEX_FIND:
return binaryExpression(Types.FIND_REGEX,node);
case REGEX_MATCH:
return binaryExpression(Types.MATCH_REGEX,node);
case RANGE_INCLUSIVE:
return rangeExpression(node,true);
case RANGE_EXCLUSIVE:
return rangeExpression(node,false);
case DYNAMIC_MEMBER:
return dynamicMemberExpression(node);
case LITERAL_in:
return binaryExpression(Types.KEYWORD_IN,node);
case ANNOTATION:
return new AnnotationConstantExpression(annotation(node));
case CLOSURE_LIST:
return closureListExpression(node);
case LBRACK:
case LPAREN:
return tupleExpression(node);
case OBJBLOCK:
return anonymousInnerClassDef(node);
default :
unknownAST(node);
}
return null;
}
