{
  int type=node.getType();
switch (type) {
case EXPR:
    return expression(node.getFirstChild());
case ELIST:
  return expressionList(node);
case CLOSED_BLOCK:
return closureExpression(node);
case SUPER_CTOR_CALL:
return superMethodCallExpression(node);
case METHOD_CALL:
return methodCallExpression(node);
case LITERAL_new:
return constructorCallExpression(node.getFirstChild());
case CTOR_CALL:
return constructorCallExpression(node);
case QUESTION:
return ternaryExpression(node);
case OPTIONAL_ARG:
return binaryExpression(Types.NAVIGATE,node);
case DOT:
return dotExpression(node);
case IDENT:
case LITERAL_boolean:
case LITERAL_byte:
case LITERAL_char:
case LITERAL_double:
case LITERAL_float:
case LITERAL_int:
case LITERAL_long:
case LITERAL_short:
return variableExpression(node);
case LIST_CONSTRUCTOR:
return listExpression(node);
case MAP_CONSTRUCTOR:
return mapExpression(node);
case LABELED_ARG:
return mapEntryExpression(node);
case INDEX_OP:
return indexExpression(node);
case LITERAL_instanceof:
return instanceofExpression(node);
case LITERAL_as:
return asExpression(node);
case TYPECAST:
return castExpression(node);
case LITERAL_true:
return ConstantExpression.TRUE;
case LITERAL_false:
return ConstantExpression.FALSE;
case LITERAL_null:
return ConstantExpression.NULL;
case STRING_LITERAL:
return new ConstantExpression(node.getText());
case STRING_CONSTRUCTOR:
return gstring(node);
case NUM_DOUBLE:
case NUM_FLOAT:
case NUM_BIG_DECIMAL:
return decimalExpression(node);
case NUM_BIG_INT:
case NUM_INT:
case NUM_LONG:
return integerExpression(node);
case LITERAL_this:
return VariableExpression.THIS_EXPRESSION;
case LITERAL_super:
return VariableExpression.SUPER_EXPRESSION;
case LNOT:
return new NotExpression(expression(node.getFirstChild()));
case UNARY_MINUS:
return negateExpression(node);
case BNOT:
return new BitwiseNegExpression(expression(node.getFirstChild()));
case UNARY_PLUS:
return expression(node.getFirstChild());
case INC:
return prefixExpression(node,Types.PLUS_PLUS);
case DEC:
return prefixExpression(node,Types.MINUS_MINUS);
case POST_INC:
return postfixExpression(node,Types.PLUS_PLUS);
case POST_DEC:
return postfixExpression(node,Types.MINUS_MINUS);
case ASSIGN:
return binaryExpression(Types.ASSIGN,node);
case EQUAL:
return binaryExpression(Types.COMPARE_EQUAL,node);
case NOT_EQUAL:
return binaryExpression(Types.COMPARE_NOT_EQUAL,node);
case COMPARE_TO:
return binaryExpression(Types.COMPARE_TO,node);
case LE:
return binaryExpression(Types.COMPARE_LESS_THAN_EQUAL,node);
case LT:
return binaryExpression(Types.COMPARE_LESS_THAN,node);
case GT:
return binaryExpression(Types.COMPARE_GREATER_THAN,node);
case GE:
return binaryExpression(Types.COMPARE_GREATER_THAN_EQUAL,node);
case LAND:
return binaryExpression(Types.LOGICAL_AND,node);
case LOR:
return binaryExpression(Types.LOGICAL_OR,node);
case BAND:
return binaryExpression(Types.BITWISE_AND,node);
case BAND_ASSIGN:
return binaryExpression(Types.BITWISE_AND_EQUAL,node);
case BOR:
return binaryExpression(Types.BITWISE_OR,node);
case BOR_ASSIGN:
return binaryExpression(Types.BITWISE_OR_EQUAL,node);
case BXOR:
return binaryExpression(Types.BITWISE_XOR,node);
case BXOR_ASSIGN:
return binaryExpression(Types.BITWISE_XOR_EQUAL,node);
case PLUS:
return binaryExpression(Types.PLUS,node);
case PLUS_ASSIGN:
return binaryExpression(Types.PLUS_EQUAL,node);
case MINUS:
return binaryExpression(Types.MINUS,node);
case MINUS_ASSIGN:
return binaryExpression(Types.MINUS_EQUAL,node);
case STAR:
return binaryExpression(Types.MULTIPLY,node);
case STAR_ASSIGN:
return binaryExpression(Types.MULTIPLY_EQUAL,node);
case STAR_STAR:
return binaryExpression(Types.POWER,node);
case STAR_STAR_ASSIGN:
return binaryExpression(Types.POWER_EQUAL,node);
case DIV:
return binaryExpression(Types.DIVIDE,node);
case DIV_ASSIGN:
return binaryExpression(Types.DIVIDE_EQUAL,node);
case MOD:
return binaryExpression(Types.MOD,node);
case MOD_ASSIGN:
return binaryExpression(Types.MOD_EQUAL,node);
case SL:
return binaryExpression(Types.LEFT_SHIFT,node);
case SL_ASSIGN:
return binaryExpression(Types.LEFT_SHIFT_EQUAL,node);
case SR:
return binaryExpression(Types.RIGHT_SHIFT,node);
case SR_ASSIGN:
return binaryExpression(Types.RIGHT_SHIFT_EQUAL,node);
case BSR:
return binaryExpression(Types.RIGHT_SHIFT_UNSIGNED,node);
case BSR_ASSIGN:
return binaryExpression(Types.RIGHT_SHIFT_UNSIGNED_EQUAL,node);
case REGEX_FIND:
return binaryExpression(Types.FIND_REGEX,node);
case REGEX_MATCH:
return binaryExpression(Types.MATCH_REGEX,node);
case RANGE_INCLUSIVE:
return rangeExpression(node,true);
case RANGE_EXCLUSIVE:
return rangeExpression(node,false);
default :
unknownAST(node);
}
return null;
}
