{
  AST node=methodCallNode.getFirstChild();
  Expression objectExpression;
  AST selector;
  AST elist=node.getNextSibling();
  boolean implicitThis=false;
  boolean safe=isType(OPTIONAL_DOT,node);
  boolean spreadSafe=isType(SPREAD_DOT,node);
  if (isType(DOT,node) || safe || spreadSafe) {
    AST objectNode=node.getFirstChild();
    objectExpression=expression(objectNode);
    selector=objectNode.getNextSibling();
  }
 else {
    implicitThis=true;
    objectExpression=VariableExpression.THIS_EXPRESSION;
    selector=node;
  }
  Expression name=null;
  if (isType(LITERAL_super,selector)) {
    implicitThis=true;
    name=new ConstantExpression("super");
    if (objectExpression == VariableExpression.THIS_EXPRESSION) {
      objectExpression=VariableExpression.SUPER_EXPRESSION;
    }
  }
 else   if (isPrimitiveTypeLiteral(selector)) {
    throw new ASTRuntimeException(selector,"Primitive type literal: " + selector.getText() + " cannot be used as a method name");
  }
 else   if (isType(SELECT_SLOT,selector)) {
    Expression field=expression(selector.getFirstChild(),true);
    AttributeExpression attributeExpression=new AttributeExpression(objectExpression,field,node.getType() != DOT);
    configureAST(attributeExpression,node);
    Expression arguments=arguments(elist);
    MethodCallExpression expression=new MethodCallExpression(attributeExpression,"call",arguments);
    configureAST(expression,methodCallNode);
    return expression;
  }
 else   if (isType(DYNAMIC_MEMBER,selector) || isType(IDENT,selector) || isType(STRING_CONSTRUCTOR,selector)|| isType(STRING_LITERAL,selector)) {
    name=expression(selector,true);
  }
 else {
    implicitThis=false;
    name=new ConstantExpression("call");
    objectExpression=expression(selector,true);
  }
  Expression arguments=arguments(elist);
  MethodCallExpression expression=new MethodCallExpression(objectExpression,name,arguments);
  expression.setSafe(safe);
  expression.setSpreadSafe(spreadSafe);
  expression.setImplicitThis(implicitThis);
  Expression ret=expression;
  if (implicitThis && "this".equals(expression.getMethodAsString())) {
    ret=new ConstructorCallExpression(this.classNode,arguments);
  }
  configureAST(ret,methodCallNode);
  return ret;
}
