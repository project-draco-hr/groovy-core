{
  assertNodeType(MODIFIERS,modifierNode);
  boolean access=false;
  int answer=0;
  Map<ClassNode,AnnotationNode> tmpAnnotations=new HashMap<ClassNode,AnnotationNode>();
  for (AST node=modifierNode.getFirstChild(); node != null; node=node.getNextSibling()) {
    int type=node.getType();
switch (type) {
case STATIC_IMPORT:
      break;
case ANNOTATION:
    AnnotationNode annNode=annotation(node);
  AnnotationNode anyPrevAnnNode=tmpAnnotations.put(annNode.getClassNode(),annNode);
if (anyPrevAnnNode != null) {
  throw new ASTRuntimeException(modifierNode,"Cannot specify duplicate annotation on the same member : " + annNode.getClassNode().getName());
}
annotations.add(annNode);
break;
case LITERAL_private:
answer=setModifierBit(node,answer,Opcodes.ACC_PRIVATE);
access=setAccessTrue(node,access);
break;
case LITERAL_protected:
answer=setModifierBit(node,answer,Opcodes.ACC_PROTECTED);
access=setAccessTrue(node,access);
break;
case LITERAL_public:
answer=setModifierBit(node,answer,Opcodes.ACC_PUBLIC);
access=setAccessTrue(node,access);
break;
case ABSTRACT:
answer=setModifierBit(node,answer,Opcodes.ACC_ABSTRACT);
break;
case FINAL:
answer=setModifierBit(node,answer,Opcodes.ACC_FINAL);
break;
case LITERAL_native:
answer=setModifierBit(node,answer,Opcodes.ACC_NATIVE);
break;
case LITERAL_static:
answer=setModifierBit(node,answer,Opcodes.ACC_STATIC);
break;
case STRICTFP:
answer=setModifierBit(node,answer,Opcodes.ACC_STRICT);
break;
case LITERAL_synchronized:
answer=setModifierBit(node,answer,Opcodes.ACC_SYNCHRONIZED);
break;
case LITERAL_transient:
answer=setModifierBit(node,answer,Opcodes.ACC_TRANSIENT);
break;
case LITERAL_volatile:
answer=setModifierBit(node,answer,Opcodes.ACC_VOLATILE);
break;
default :
unknownAST(node);
}
}
if (!access) {
answer|=defaultModifiers;
}
return answer;
}
