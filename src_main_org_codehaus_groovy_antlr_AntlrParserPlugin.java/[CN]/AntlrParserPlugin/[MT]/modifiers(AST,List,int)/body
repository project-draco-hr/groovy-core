{
  assertNodeType(MODIFIERS,modifierNode);
  boolean access=false;
  int answer=0;
  for (AST node=modifierNode.getFirstChild(); node != null; node=node.getNextSibling()) {
    int type=node.getType();
switch (type) {
case ANNOTATION:
      annotations.add(annotation(node));
    break;
case LITERAL_private:
  answer=setModifierBit(node,answer,Constants.ACC_PRIVATE);
access=setAccessTrue(node,access);
break;
case LITERAL_protected:
answer=setModifierBit(node,answer,Constants.ACC_PROTECTED);
access=setAccessTrue(node,access);
break;
case LITERAL_public:
answer=setModifierBit(node,answer,Constants.ACC_PUBLIC);
access=setAccessTrue(node,access);
break;
case ABSTRACT:
answer=setModifierBit(node,answer,Constants.ACC_ABSTRACT);
break;
case FINAL:
answer=setModifierBit(node,answer,Constants.ACC_FINAL);
break;
case LITERAL_native:
answer=setModifierBit(node,answer,Constants.ACC_NATIVE);
break;
case LITERAL_static:
answer=setModifierBit(node,answer,Constants.ACC_STATIC);
break;
case STRICTFP:
answer=setModifierBit(node,answer,Constants.ACC_STRICT);
break;
case LITERAL_synchronized:
answer=setModifierBit(node,answer,Constants.ACC_SYNCHRONIZED);
break;
case LITERAL_transient:
answer=setModifierBit(node,answer,Constants.ACC_TRANSIENT);
break;
case LITERAL_volatile:
answer=setModifierBit(node,answer,Constants.ACC_VOLATILE);
break;
default :
unknownAST(node);
}
}
if (!access) {
answer|=defaultModifiers;
}
return answer;
}
