{
  if (nodes.length != 2 || !(nodes[0] instanceof AnnotationNode) || !(nodes[1] instanceof AnnotatedNode)) {
    throw new GroovyBugError("Internal error: expecting [AnnotationNode, AnnotatedNode] but got: " + Arrays.asList(nodes));
  }
  AnnotatedNode parent=(AnnotatedNode)nodes[1];
  AnnotationNode node=(AnnotationNode)nodes[0];
  if (!MY_TYPE.equals(node.getClassNode()))   return;
  if (parent instanceof ClassNode) {
    ClassNode cNode=(ClassNode)parent;
    if (cNode.isInterface()) {
      addError("Error processing interface '" + cNode.getName() + "'. "+ MY_TYPE_NAME+ " only allowed for classes.",cNode,source);
      return;
    }
    ClassNode sNode=cNode.getSuperClass();
    for (    ConstructorNode cn : sNode.getDeclaredConstructors()) {
      Parameter[] params=cn.getParameters();
      if (cn.isPrivate())       continue;
      Parameter[] pcopy=new Parameter[params.length];
      List<Expression> args=new ArrayList<Expression>();
      for (int i=0; i < params.length; i++) {
        Parameter p=params[i];
        pcopy[i]=p.hasInitialExpression() ? new Parameter(p.getType(),p.getName(),p.getInitialExpression()) : new Parameter(p.getType(),p.getName());
        args.add(new VariableExpression(p.getName(),p.getType()));
      }
      if (isClashing(cNode,pcopy))       continue;
      BlockStatement body=new BlockStatement();
      body.addStatement(new ExpressionStatement(new ConstructorCallExpression(ClassNode.SUPER,new ArgumentListExpression(args))));
      cNode.addConstructor(cn.getModifiers(),pcopy,cn.getExceptions(),body);
    }
  }
}
