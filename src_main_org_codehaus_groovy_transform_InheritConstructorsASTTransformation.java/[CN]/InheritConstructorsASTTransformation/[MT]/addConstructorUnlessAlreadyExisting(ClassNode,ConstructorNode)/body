{
  Parameter[] origParams=consNode.getParameters();
  if (consNode.isPrivate())   return;
  Parameter[] params=new Parameter[origParams.length];
  List<Expression> theArgs=new ArrayList<Expression>();
  Map<String,ClassNode> genericsSpec=createGenericsSpec(classNode);
  extractSuperClassGenerics(classNode,classNode.getSuperClass(),genericsSpec);
  for (int i=0; i < origParams.length; i++) {
    Parameter p=origParams[i];
    ClassNode newType=correctToGenericsSpecRecurse(genericsSpec,p.getType());
    params[i]=p.hasInitialExpression() ? param(newType,p.getName(),p.getInitialExpression()) : param(newType,p.getName());
    theArgs.add(varX(p.getName(),newType));
  }
  if (isExisting(classNode,params))   return;
  classNode.addConstructor(consNode.getModifiers(),params,consNode.getExceptions(),block(ctorSuperS(args(theArgs))));
}
