{
  String name=codeSource.getName();
  Class answer=null;
synchronized (cache) {
    answer=(Class)cache.get(name);
    if (answer != null) {
      return (answer == PARSING.class ? null : answer);
    }
 else {
      cache.put(name,PARSING.class);
    }
  }
  try {
    CompilationUnit unit=new CompilationUnit(config,codeSource.getCodeSource(),this);
    ClassCollector collector=createCollector(unit);
    if (codeSource.getFile() == null) {
      unit.addSource(name,codeSource.getInputStream());
    }
 else {
      unit.addSource(codeSource.getFile());
    }
    unit.setClassgenCallback(collector);
    unit.compile(Phases.CLASS_GENERATION);
    answer=collector.generatedClass;
  }
  finally {
synchronized (cache) {
      if (answer == null || !shouldCache) {
        cache.remove(name);
      }
 else {
        cache.put(name,answer);
      }
    }
    try {
      codeSource.getInputStream().close();
    }
 catch (    IOException e) {
      throw new GroovyRuntimeException("unable to close stream",e);
    }
  }
  return answer;
}
