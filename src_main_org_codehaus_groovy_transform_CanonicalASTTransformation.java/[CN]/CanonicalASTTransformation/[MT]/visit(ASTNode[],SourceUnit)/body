{
  init(nodes,source);
  AnnotatedNode parent=(AnnotatedNode)nodes[1];
  AnnotationNode anno=(AnnotationNode)nodes[0];
  if (!MY_TYPE.equals(anno.getClassNode()))   return;
  if (parent instanceof ClassNode) {
    ClassNode cNode=(ClassNode)parent;
    if (hasAnnotation(cNode,ImmutableASTTransformation.MY_TYPE)) {
      addError(MY_TYPE_NAME + " class '" + cNode.getName()+ "' can't also be "+ ImmutableASTTransformation.MY_TYPE_NAME,parent);
    }
    checkNotInterface(cNode,MY_TYPE_NAME);
    List<String> excludes=tokenize((String)getMemberValue(anno,"excludes"));
    List<String> includes=tokenize((String)getMemberValue(anno,"includes"));
    if (includes != null && !includes.isEmpty() && excludes != null && !excludes.isEmpty()) {
      addError("Error during " + MY_TYPE_NAME + " processing: Only one of 'includes' and 'excludes' should be supplied not both.",anno);
    }
    if (!hasAnnotation(cNode,TupleConstructorASTTransformation.MY_TYPE)) {
      createConstructor(cNode,false,true,false,false,false,false,excludes,includes);
    }
    if (!hasAnnotation(cNode,EqualsAndHashCodeASTTransformation.MY_TYPE)) {
      createHashCode(cNode,false,false,false,excludes,includes);
      createEquals(cNode,false,false,true,excludes,includes);
    }
    if (!hasAnnotation(cNode,ToStringASTTransformation.MY_TYPE)) {
      createToString(cNode,false,false,excludes,includes,false);
    }
  }
}
