{
  this.name=name;
  this.modifiers=modifiers;
  this.superClass=superClass;
  this.interfaces=interfaces;
  this.mixins=mixins;
  isPrimaryNode=true;
  if (superClass != null) {
    usesGenerics=superClass.isUsingGenerics();
  }
  if (!usesGenerics && interfaces != null) {
    for (int i=0; i < interfaces.length; i++) {
      usesGenerics=usesGenerics || interfaces[i].isUsingGenerics();
    }
  }
  this.methods=new MapOfLists();
  this.methodsList=new ArrayList();
  if ((modifiers & ACC_INTERFACE) == 0)   addField("$ownClass",ACC_STATIC | ACC_PUBLIC | ACC_FINAL| ACC_SYNTHETIC,ClassHelper.CLASS_Type,new ClassExpression(this)).setSynthetic(true);
  singleNodeTransformInstances=new EnumMap<CompilePhase,Map<ASTSingleNodeTransformation,ASTNode>>(CompilePhase.class);
  for (  CompilePhase phase : CompilePhase.values()) {
    singleNodeTransformInstances.put(phase,new HashMap<ASTSingleNodeTransformation,ASTNode>());
  }
  classTransforms=new EnumMap<CompilePhase,List<CompilationUnit.PrimaryClassNodeOperation>>(CompilePhase.class);
  for (  CompilePhase phase : CompilePhase.values()) {
    classTransforms.put(phase,new ArrayList<CompilationUnit.PrimaryClassNodeOperation>());
  }
}
