{
  ModuleNode module=currentClass.getModule();
  if (module == null)   return false;
  String name=type.getName();
  if (!type.hasPackageName() && module.hasPackageName()) {
    type.setName(module.getPackageName() + name);
  }
  List moduleClasses=module.getClasses();
  for (Iterator iter=moduleClasses.iterator(); iter.hasNext(); ) {
    ClassNode mClass=(ClassNode)iter.next();
    if (mClass.getName().equals(type.getName())) {
      if (mClass != type)       type.setRedirect(mClass);
      return true;
    }
  }
  type.setName(name);
{
    String aliased=module.getImport(name);
    if (aliased != null && !aliased.equals(name)) {
      type.setName(aliased);
      boolean useInnerStaticClasses=aliased.indexOf('.') == -1;
      if (resolve(type,true,true,useInnerStaticClasses))       return true;
      type.setName(name);
    }
  }
  testModuleImports&=!type.hasPackageName();
  if (testModuleImports) {
    String packageName="";
    if (module.hasPackageName())     packageName=module.getPackageName();
    type.setName(packageName + name);
    boolean resolved=resolve(type,false,false,false);
    List packages=module.getImportPackages();
    ClassNode iType=ClassHelper.make(name);
    for (Iterator iter=packages.iterator(); iter.hasNext(); ) {
      String packagePrefix=(String)iter.next();
      String fqn=packagePrefix + name;
      iType.setName(fqn);
      if (resolve(iType,false,false,false)) {
        if (resolved) {
          addError("reference to " + name + " is ambigous, both class "+ type.getName()+ " and "+ fqn+ " match",type);
        }
 else {
          type.setRedirect(iType);
        }
        return true;
      }
      iType.setName(name);
    }
    if (!resolved)     type.setName(name);
    return resolved;
  }
  return false;
}
