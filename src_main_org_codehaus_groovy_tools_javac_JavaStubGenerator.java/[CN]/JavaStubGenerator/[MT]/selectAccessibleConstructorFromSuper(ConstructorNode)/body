{
  ClassNode type=node.getDeclaringClass();
  ClassNode superType=type.getSuperClass();
  for (Iterator iter=superType.getDeclaredConstructors().iterator(); iter.hasNext(); ) {
    ConstructorNode c=(ConstructorNode)iter.next();
    if (c.isPublic() || c.isProtected()) {
      return c;
    }
  }
  if (!superType.isResolved()) {
    throw new Error("Super-class (" + superType.getName() + ")should have been resolved already for type: "+ type.getName());
  }
  Constructor[] constructors=superType.getTypeClass().getDeclaredConstructors();
  for (int i=0; i < constructors.length; i++) {
    int mod=constructors[i].getModifiers();
    if (Modifier.isPublic(mod) || Modifier.isProtected(mod)) {
      Class[] types=constructors[i].getParameterTypes();
      Parameter[] params=new Parameter[types.length];
      for (int j=0; j < types.length; j++) {
        ClassNode ptype=ClassHelper.make(types[j]);
        params[j]=new Parameter(ptype,types[j].getName());
      }
      return new ConstructorNode(mod,params,null,null);
    }
  }
  return null;
}
