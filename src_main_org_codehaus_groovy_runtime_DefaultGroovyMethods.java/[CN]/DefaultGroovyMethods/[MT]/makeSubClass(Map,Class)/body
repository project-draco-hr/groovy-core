{
  String name=shortName(clazz.getName()) + "_groovyProxy";
  StringBuilder builder=new StringBuilder();
  builder.append("class ").append(name).append(" extends ").append(clazz.getName()).append(" {\n").append("private closureMap\n").append(name).append("(map) {\n").append("super()\n").append("this.closureMap = map\n").append("}\n");
  List selectedMethods=new ArrayList();
  Method[] methods=clazz.getMethods();
  for (int i=0; i < methods.length; i++) {
    if (map.containsKey(methods[i].getName())) {
      selectedMethods.add(methods[i].getName());
      builder.append(methods[i].getReturnType().getName()).append(" ").append(methods[i].getName()).append(" (");
      Class[] parameterTypes=methods[i].getParameterTypes();
      boolean first=true;
      for (int parameterTypeIndex=0; parameterTypeIndex < parameterTypes.length; parameterTypeIndex++) {
        Class parameter=parameterTypes[parameterTypeIndex];
        if (!first) {
          builder.append(", ");
        }
 else {
          first=false;
        }
        builder.append(parameter.getName()).append(" ").append("p").append(parameterTypeIndex);
      }
      builder.append(") {this.@closureMap['").append(methods[i].getName()).append("'](");
      first=true;
      for (int j=0; j < parameterTypes.length; j++) {
        if (!first) {
          builder.append(", ");
        }
 else {
          first=false;
        }
        builder.append("p").append(j);
      }
      builder.append(")}\n");
    }
  }
  for (Iterator iterator=map.keySet().iterator(); iterator.hasNext(); ) {
    String methodName=(String)iterator.next();
    if (selectedMethods.contains(methodName))     continue;
    builder.append("def ").append(methodName).append("(Object[] args {\n").append("this.@closureMap['").append(methodName).append("'](*args)\n}\n");
  }
  builder.append("}\n").append("new ").append(name).append("(map)");
  Binding binding=new Binding();
  binding.setVariable("map",map);
  GroovyShell shell=new GroovyShell(clazz.getClassLoader(),binding);
  try {
    return shell.evaluate(builder.toString());
  }
 catch (  MultipleCompilationErrorsException err) {
    throw new GroovyCastException(map,clazz);
  }
}
