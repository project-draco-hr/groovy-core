{
  final List<PropertyNode> pList=getInstanceProperties(cNode);
  final List<FieldNode> fList=new ArrayList<FieldNode>();
  if (includeFields) {
    fList.addAll(getInstanceNonPropertyFields(cNode));
  }
  final BlockStatement body=new BlockStatement();
  final Expression result=var("_result");
  body.addStatement(declS(result,callX(HASHUTIL_TYPE,"initHash")));
  for (  PropertyNode pNode : pList) {
    if (shouldSkip(pNode.getName(),excludes,includes))     continue;
    Expression getter=callX(INVOKERHELPER_TYPE,"getProperty",args(var("this"),constX(pNode.getName())));
    final Expression current=callX(HASHUTIL_TYPE,"updateHash",args(result,getter));
    body.addStatement(ifS(not(identicalX(getter,var("this"))),assignS(result,current)));
  }
  for (  FieldNode fNode : fList) {
    if (shouldSkip(fNode.getName(),excludes,includes))     continue;
    final Expression fieldExpr=var(fNode);
    final Expression current=callX(HASHUTIL_TYPE,"updateHash",args(result,fieldExpr));
    body.addStatement(ifS(not(identicalX(fieldExpr,var("this"))),assignS(result,current)));
  }
  if (callSuper) {
    final Expression current=callX(HASHUTIL_TYPE,"updateHash",args(result,callSuperX("hashCode")));
    body.addStatement(assignS(result,current));
  }
  if (hash != null) {
    body.addStatement(assignS(hash,result));
  }
 else {
    body.addStatement(returnS(result));
  }
  return body;
}
