{
  final List<PropertyNode> pList=getInstanceProperties(cNode);
  final List<FieldNode> fList=new ArrayList<FieldNode>();
  if (includeFields) {
    fList.addAll(getInstanceNonPropertyFields(cNode));
  }
  final BlockStatement body=new BlockStatement();
  final Expression result=new VariableExpression("_result");
  final Expression init=new StaticMethodCallExpression(HASHUTIL_TYPE,"initHash",MethodCallExpression.NO_ARGUMENTS);
  body.addStatement(new ExpressionStatement(new DeclarationExpression(result,ASSIGN,init)));
  for (  PropertyNode pNode : pList) {
    if (shouldSkip(pNode.getName(),excludes,includes))     continue;
    String getterName="get" + Verifier.capitalize(pNode.getName());
    Expression getter=new MethodCallExpression(VariableExpression.THIS_EXPRESSION,getterName,MethodCallExpression.NO_ARGUMENTS);
    final Expression args=new TupleExpression(result,getter);
    final Expression current=new StaticMethodCallExpression(HASHUTIL_TYPE,"updateHash",args);
    body.addStatement(assignStatement(result,current));
  }
  for (  FieldNode fNode : fList) {
    if (shouldSkip(fNode.getName(),excludes,includes))     continue;
    final Expression fieldExpr=new VariableExpression(fNode);
    final Expression args=new TupleExpression(result,fieldExpr);
    final Expression current=new StaticMethodCallExpression(HASHUTIL_TYPE,"updateHash",args);
    body.addStatement(assignStatement(result,current));
  }
  if (callSuper) {
    final Expression args=new TupleExpression(result,new MethodCallExpression(VariableExpression.SUPER_EXPRESSION,"hashCode",MethodCallExpression.NO_ARGUMENTS));
    final Expression current=new StaticMethodCallExpression(HASHUTIL_TYPE,"updateHash",args);
    body.addStatement(assignStatement(result,current));
  }
  if (hash != null) {
    body.addStatement(assignStatement(hash,result));
  }
 else {
    body.addStatement(new ReturnStatement(result));
  }
  return body;
}
