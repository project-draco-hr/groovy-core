{
  boolean oldInPropertyExpression=inPropertyExpression;
  Expression oldFoundArgs=foundArgs;
  Expression oldFoundMethod=foundConstant;
  inPropertyExpression=true;
  foundArgs=null;
  foundConstant=null;
  Expression objectExpression=transform(pe.getObjectExpression());
  if (objectExpression instanceof ClassExpression && currentMethod != null && currentMethod.isStatic()) {
    ClassExpression ce=(ClassExpression)objectExpression;
    if (ce.getType().getName().equals(currentClass.getName())) {
      FieldNode field=currentClass.getDeclaredField(pe.getPropertyAsString());
      if (field != null && field.isStatic()) {
        Expression expression=new FieldExpression(field);
        expression.setSourcePosition(pe);
        return expression;
      }
    }
  }
  if (objectExpression instanceof VariableExpression) {
    VariableExpression ve=(VariableExpression)objectExpression;
    boolean isExplicitSuper=ve.getName().equals("super");
    if (isExplicitSuper && currentMethod != null && currentMethod.isStatic()) {
      addError("'super' cannot be used in a static context, use the explicit class instead.",pe);
      return null;
    }
  }
  if (foundArgs != null && foundConstant != null) {
    Expression result=findStaticMethodImportFromModule(foundConstant,foundArgs);
    if (result != null) {
      objectExpression=result;
    }
  }
  inPropertyExpression=oldInPropertyExpression;
  foundArgs=oldFoundArgs;
  foundConstant=oldFoundMethod;
  pe.setObjectExpression(objectExpression);
  if (!inSpecialConstructorCall)   checkStaticScope(pe);
  return pe;
}
