{
  Map map=new HashMap();
  if (closureMap != null) {
    map=closureMap;
  }
  List selectedMethods=new ArrayList();
  List interfacesToImplement=new ArrayList();
  if (interfaces != null) {
    interfacesToImplement=interfaces;
  }
  StringBuffer buffer=new StringBuffer();
  buffer.append("import org.codehaus.groovy.runtime.InvokerHelper\nclass ").append(name);
  if (baseClass != null) {
    buffer.append(" extends ").append(baseClass.getName());
  }
  for (int i=0; i < interfacesToImplement.size(); i++) {
    Class thisInterface=(Class)interfacesToImplement.get(i);
    if (i == 0) {
      buffer.append(" implements ");
    }
 else {
      buffer.append(", ");
    }
    buffer.append(thisInterface.getName());
  }
  buffer.append(" {\n").append("    private delegate\n").append("    private closureMap\n    ");
  buffer.append(name).append("(map, delegate) {\n");
  buffer.append("        this.closureMap = map\n");
  buffer.append("        this.delegate = delegate\n");
  buffer.append("    }\n");
  List objectMethods=DefaultGroovyMethods.toList(Object.class.getMethods());
  objectMethods.addAll(getInheritedMethods(Object.class));
  List groovyObjectMethods=DefaultGroovyMethods.toList(GroovyObject.class.getMethods());
  groovyObjectMethods.addAll(getInheritedMethods(GroovyObject.class));
  List interfaceMethods=new ArrayList();
  for (int i=0; i < interfacesToImplement.size(); i++) {
    Class thisInterface=(Class)interfacesToImplement.get(i);
    interfaceMethods.addAll(DefaultGroovyMethods.toList(thisInterface.getMethods()));
    interfaceMethods.addAll(getInheritedMethods(thisInterface));
  }
  for (int i=0; i < interfaceMethods.size(); i++) {
    Method method=(Method)interfaceMethods.get(i);
    if (!containsEquivalentMethod(objectMethods,method) && !containsEquivalentMethod(groovyObjectMethods,method)) {
      selectedMethods.add(method.getName());
      addWrappedCall(buffer,method,map);
    }
  }
  List additionalMethods=new ArrayList();
  additionalMethods.addAll(DefaultGroovyMethods.toList(delegate.getClass().getMethods()));
  additionalMethods.addAll(getInheritedMethods(delegate.getClass()));
  for (int i=0; i < additionalMethods.size(); i++) {
    Method method=(Method)additionalMethods.get(i);
    if (method.getName().indexOf('$') != -1)     continue;
    if (!containsEquivalentMethod(interfaceMethods,method) && !containsEquivalentMethod(objectMethods,method) && !containsEquivalentMethod(groovyObjectMethods,method)) {
      selectedMethods.add(method.getName());
      addWrappedCall(buffer,method,map);
    }
  }
  for (Iterator iterator=map.keySet().iterator(); iterator.hasNext(); ) {
    String methodName=(String)iterator.next();
    if (selectedMethods.contains(methodName))     continue;
    addNewMapCall(buffer,methodName);
  }
  buffer.append("}\n").append("new ").append(name);
  buffer.append("(map, delegate)");
  Binding binding=new Binding();
  binding.setVariable("map",map);
  binding.setVariable("delegate",delegate);
  ClassLoader cl=override != null ? override : delegate.getClass().getClassLoader();
  GroovyShell shell=new GroovyShell(cl,binding);
  if (debug)   System.out.println("proxy source:\n------------------\n" + buffer.toString() + "\n------------------");
  try {
    return shell.evaluate(buffer.toString());
  }
 catch (  MultipleCompilationErrorsException err) {
    throw new GroovyRuntimeException("Error creating proxy: " + err.getMessage());
  }
}
