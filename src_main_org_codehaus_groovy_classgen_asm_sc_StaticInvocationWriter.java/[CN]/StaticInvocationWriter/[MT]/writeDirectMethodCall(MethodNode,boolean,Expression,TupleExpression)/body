{
  if (target instanceof ExtensionMethodNode) {
    MethodNode node=((ExtensionMethodNode)target).getExtensionMethodNode();
    String methodName=target.getName();
    MethodVisitor mv=controller.getMethodVisitor();
    int argumentsToRemove=0;
    List<Expression> argumentList=new LinkedList<Expression>(args.getExpressions());
    argumentList.add(0,receiver);
    Parameter[] parameters=node.getParameters();
    loadArguments(argumentList,parameters);
    String owner=BytecodeHelper.getClassInternalName(node.getDeclaringClass());
    String desc=BytecodeHelper.getMethodDescriptor(target.getReturnType(),parameters);
    mv.visitMethodInsn(INVOKESTATIC,owner,methodName,desc);
    ClassNode ret=target.getReturnType().redirect();
    if (ret == ClassHelper.VOID_TYPE) {
      ret=ClassHelper.OBJECT_TYPE;
      mv.visitInsn(ACONST_NULL);
    }
    argumentsToRemove+=argumentList.size();
    controller.getOperandStack().remove(argumentsToRemove);
    controller.getOperandStack().push(ret);
    return true;
  }
 else {
    if (target == StaticTypeCheckingVisitor.CLOSURE_CALL_VARGS) {
      ArrayExpression arr=new ArrayExpression(ClassHelper.OBJECT_TYPE,args.getExpressions());
      return super.writeDirectMethodCall(target,implicitThis,receiver,new ArgumentListExpression(arr));
    }
    if (target != null && controller.getClassNode().isDerivedFrom(ClassHelper.CLOSURE_TYPE) && controller.isInClosure() && !target.isPublic() && target.getDeclaringClass() != controller.getClassNode()) {
      ArrayExpression arr=new ArrayExpression(ClassHelper.OBJECT_TYPE,args.getExpressions());
      MethodCallExpression mce=new MethodCallExpression(INVOKERHELER_RECEIVER,target.isStatic() ? "invokeStaticMethod" : "invokeMethodSafe",new ArgumentListExpression(receiver,new ConstantExpression(target.getName()),arr));
      mce.setMethodTarget(target.isStatic() ? INVOKERHELPER_INVOKESTATICMETHOD : INVOKERHELPER_INVOKEMETHOD);
      mce.visit(controller.getAcg());
      return true;
    }
    if (target != null && target.isPrivate()) {
      ClassNode declaringClass=target.getDeclaringClass();
      if (declaringClass instanceof InnerClassNode && declaringClass.getNodeMetaData(StaticCompilationMetadataKeys.PRIVATE_BRIDGE_METHODS) != null && declaringClass != controller.getClassNode()) {
        @SuppressWarnings("unchecked") Map<MethodNode,MethodNode> bridges=(Map<MethodNode,MethodNode>)declaringClass.getNodeMetaData(StaticCompilationMetadataKeys.PRIVATE_BRIDGE_METHODS);
        MethodNode bridge=bridges.get(target);
        if (bridge != null) {
          return writeDirectMethodCall(bridge,implicitThis,receiver,args);
        }
      }
      if (declaringClass != controller.getClassNode()) {
        controller.getSourceUnit().addError(new SyntaxException("Cannot call private method " + (target.isStatic() ? "static " : "") + declaringClass.toString(false)+ "#"+ target.getName()+ " from class "+ controller.getClassNode().toString(false),receiver.getLineNumber(),receiver.getColumnNumber()));
      }
    }
    return super.writeDirectMethodCall(target,implicitThis,receiver,args);
  }
}
