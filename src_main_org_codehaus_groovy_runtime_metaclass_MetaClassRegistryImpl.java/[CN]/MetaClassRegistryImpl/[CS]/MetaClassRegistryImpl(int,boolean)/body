{
  this.useAccessible=useAccessible;
  if (loadDefault == LOAD_DEFAULT) {
    Map<CachedClass,List<MetaMethod>> map=new HashMap<CachedClass,List<MetaMethod>>();
    registerMethods(null,true,true,map);
    final Class[] additionals=DefaultGroovyMethods.additionals;
    for (int i=0; i != additionals.length; ++i) {
      createMetaMethodFromClass(map,additionals[i]);
    }
    Class[] pluginDGMs=VMPluginFactory.getPlugin().getPluginDefaultGroovyMethods();
    for (    Class plugin : pluginDGMs) {
      registerMethods(plugin,false,true,map);
    }
    registerMethods(DefaultGroovyStaticMethods.class,false,false,map);
    for (    Map.Entry<CachedClass,List<MetaMethod>> e : map.entrySet()) {
      CachedClass cls=e.getKey();
      cls.setNewMopMethods(e.getValue());
    }
  }
  installMetaClassCreationHandle();
  final MetaClass emcMetaClass=metaClassCreationHandle.create(ExpandoMetaClass.class,this);
  emcMetaClass.initialize();
  ClassInfo.getClassInfo(ExpandoMetaClass.class).setStrongMetaClass(emcMetaClass);
  addMetaClassRegistryChangeEventListener(new MetaClassRegistryChangeEventListener(){
    public void updateConstantMetaClass(    MetaClassRegistryChangeEvent cmcu){
synchronized (metaClassInfo) {
        metaClassInfo.add(cmcu.getNewMetaClass());
      }
    }
  }
);
}
