{
  CachedMethod[] methods=ReflectionCache.getCachedClass(theClass).getMethods();
  if (useMethodWrapper) {
    for (int i=0; ; ++i) {
      try {
        final String className="org.codehaus.groovy.runtime.dgm$" + i;
        final Class aClass=Class.forName(className);
        createMetaMethodFromClass(map,aClass);
      }
 catch (      ClassNotFoundException e) {
        break;
      }
    }
    final Class[] additionals=DefaultGroovyMethods.additionals;
    for (int i=0; i != additionals.length; ++i) {
      createMetaMethodFromClass(map,additionals[i]);
    }
  }
 else {
    for (    CachedMethod method : methods) {
      final int mod=method.getModifiers();
      if (Modifier.isStatic(mod) && Modifier.isPublic(mod)) {
        CachedClass[] paramTypes=method.getParameterTypes();
        if (paramTypes.length > 0) {
          List<MetaMethod> arr=map.get(paramTypes[0]);
          if (arr == null) {
            arr=new ArrayList<MetaMethod>(4);
            map.put(paramTypes[0],arr);
          }
          if (useInstanceMethods) {
            final NewInstanceMetaMethod metaMethod=new NewInstanceMetaMethod(method);
            arr.add(metaMethod);
            instanceMethods.add(metaMethod);
          }
 else {
            final NewStaticMetaMethod metaMethod=new NewStaticMetaMethod(method);
            arr.add(metaMethod);
            staticMethods.add(metaMethod);
          }
        }
      }
    }
  }
}
