{
  super.visitBinaryExpression(expression);
  final Expression leftExpression=expression.getLeftExpression();
  if (leftExpression instanceof PropertyExpression) {
    PropertyExpression pexp=(PropertyExpression)leftExpression;
    if (!existsProperty(pexp)) {
      Expression objectExpression=pexp.getObjectExpression();
      addStaticTypeError("No such property: " + pexp.getPropertyAsString() + " for class: "+ findCurrentInstanceOfClass(objectExpression,objectExpression.getType()),leftExpression);
      return;
    }
  }
  ClassNode lType=getType(leftExpression,classNode);
  final Expression rightExpression=expression.getRightExpression();
  ClassNode rType=getType(rightExpression,classNode);
  int op=expression.getOperation().getType();
  ClassNode resultType=getResultType(lType,op,rType,expression);
  if (resultType == null) {
    addStaticTypeError("tbd...",expression);
    resultType=lType;
  }
  storeType(expression,resultType);
  if (isAssignment(op)) {
    ClassNode leftRedirect;
    if (isArrayAccessExpression(leftExpression) || leftExpression instanceof PropertyExpression) {
      leftRedirect=lType;
    }
 else {
      leftRedirect=leftExpression.getType().redirect();
    }
    boolean compatible=checkCompatibleAssignmentTypes(leftRedirect,resultType);
    if (!compatible) {
      addStaticTypeError("Cannot assign value of type " + resultType + " to variable of type "+ lType,expression);
    }
 else {
      boolean possibleLooseOfPrecision=false;
      if (isNumberType(leftRedirect) && isNumberType(resultType)) {
        possibleLooseOfPrecision=checkPossibleLooseOfPrecision(leftRedirect,resultType,rightExpression);
        if (possibleLooseOfPrecision) {
          addStaticTypeError("Possible loose of precision from " + resultType + " to "+ leftRedirect,rightExpression);
        }
      }
      if (!possibleLooseOfPrecision && lType.isArray()) {
        ClassNode leftComponentType=lType.getComponentType();
        ClassNode rightRedirect=rightExpression.getType().redirect();
        if (rightRedirect.isArray()) {
          ClassNode rightComponentType=rightRedirect.getComponentType();
          if (!checkCompatibleAssignmentTypes(leftComponentType,rightComponentType)) {
            addStaticTypeError("Cannot assign value of type " + rightComponentType + " into array of type "+ lType,expression);
          }
        }
 else         if (rightExpression instanceof ListExpression) {
          for (          Expression element : ((ListExpression)rightExpression).getExpressions()) {
            ClassNode rightComponentType=element.getType().redirect();
            if (!checkCompatibleAssignmentTypes(leftComponentType,rightComponentType)) {
              addStaticTypeError("Cannot assign value of type " + rightComponentType + " into array of type "+ lType,expression);
            }
          }
        }
      }
    }
    storeType(leftExpression,resultType);
  }
 else   if (op == KEYWORD_INSTANCEOF) {
    final Map<Object,List<ClassNode>> tempo=temporaryIfBranchTypeInformation.peek();
    Object key=extractTemporaryTypeInfoKey(leftExpression);
    List<ClassNode> potentialTypes=tempo.get(key);
    if (potentialTypes == null) {
      potentialTypes=new LinkedList<ClassNode>();
      tempo.put(key,potentialTypes);
    }
    potentialTypes.add(rightExpression.getType());
  }
}
