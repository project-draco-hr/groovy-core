{
  super.visitMethodCallExpression(call);
  final String name=call.getMethodAsString();
  if (name == null) {
    addStaticTypeError("cannot resolve dynamic method name at compile time.",call.getMethod());
  }
 else {
    ClassNode[] args=getArgumentTypes(InvocationWriter.makeArgumentList(call.getArguments()),classNode);
    final Expression objectExpression=call.getObjectExpression();
    final ClassNode receiver=getType(objectExpression,classNode);
    MethodNode mn=findMethod(call,receiver,name,args);
    if (mn == null && !temporaryIfBranchTypeInformation.isEmpty()) {
      Object key=extractTemporaryTypeInfoKey(objectExpression);
      final Map<Object,List<ClassNode>> tempo=temporaryIfBranchTypeInformation.peek();
      List<ClassNode> potentialReceiverType=tempo.get(key);
      if (potentialReceiverType != null) {
        for (        ClassNode potentialReceiver : potentialReceiverType) {
          mn=findMethod(call,potentialReceiver,name,args);
          if (mn != null)           break;
        }
      }
      if (mn == null) {
        addStaticTypeError("Cannot find matching method " + receiver.getName() + "#"+ toMethodParametersString(name,args),call);
        return;
      }
    }
    storeType(call,mn.getReturnType());
  }
}
