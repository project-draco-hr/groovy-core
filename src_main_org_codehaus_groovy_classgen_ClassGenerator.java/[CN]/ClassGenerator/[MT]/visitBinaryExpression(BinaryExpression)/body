{
switch (expression.getOperation().getType()) {
case Types.EQUAL:
    evaluateEqual(expression);
  break;
case Types.COMPARE_IDENTICAL:
evaluateBinaryExpression(compareIdenticalMethod,expression);
break;
case Types.COMPARE_EQUAL:
evaluateBinaryExpression(compareEqualMethod,expression);
break;
case Types.COMPARE_NOT_EQUAL:
evaluateBinaryExpression(compareNotEqualMethod,expression);
break;
case Types.COMPARE_TO:
evaluateCompareTo(expression);
break;
case Types.COMPARE_GREATER_THAN:
evaluateBinaryExpression(compareGreaterThanMethod,expression);
break;
case Types.COMPARE_GREATER_THAN_EQUAL:
evaluateBinaryExpression(compareGreaterThanEqualMethod,expression);
break;
case Types.COMPARE_LESS_THAN:
evaluateBinaryExpression(compareLessThanMethod,expression);
break;
case Types.COMPARE_LESS_THAN_EQUAL:
evaluateBinaryExpression(compareLessThanEqualMethod,expression);
break;
case Types.LOGICAL_AND:
evaluateLogicalAndExpression(expression);
break;
case Types.LOGICAL_OR:
evaluateLogicalOrExpression(expression);
break;
case Types.PLUS:
evaluateBinaryExpression("plus",expression);
break;
case Types.PLUS_EQUAL:
evaluateBinaryExpressionWithAsignment("plus",expression);
break;
case Types.MINUS:
evaluateBinaryExpression("minus",expression);
break;
case Types.MINUS_EQUAL:
evaluateBinaryExpressionWithAsignment("minus",expression);
break;
case Types.MULTIPLY:
evaluateBinaryExpression("multiply",expression);
break;
case Types.MULTIPLY_EQUAL:
evaluateBinaryExpressionWithAsignment("multiply",expression);
break;
case Types.DIVIDE:
evaluateBinaryExpression("div",expression);
break;
case Types.DIVIDE_EQUAL:
evaluateBinaryExpressionWithAsignment("div",expression);
break;
case Types.MOD:
evaluateBinaryExpression("mod",expression);
break;
case Types.MOD_EQUAL:
evaluateBinaryExpressionWithAsignment("mod",expression);
break;
case Types.LEFT_SHIFT:
evaluateBinaryExpression("leftShift",expression);
break;
case Types.RIGHT_SHIFT:
evaluateBinaryExpression("rightShift",expression);
break;
case Types.RIGHT_SHIFT_UNSIGNED:
evaluateBinaryExpression("rightShiftUnsigned",expression);
break;
case Types.KEYWORD_INSTANCEOF:
evaluateInstanceof(expression);
break;
case Types.FIND_REGEX:
evaluateBinaryExpression(findRegexMethod,expression);
break;
case Types.MATCH_REGEX:
evaluateBinaryExpression(matchRegexMethod,expression);
break;
case Types.LEFT_SQUARE_BRACKET:
if (leftHandExpression) {
throw new RuntimeException("Should not be called");
}
 else {
evaluateBinaryExpression("getAt",expression);
}
break;
default :
throw new ClassGeneratorException("Operation: " + expression.getOperation() + " not supported");
}
}
