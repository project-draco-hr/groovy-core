{
switch (expression.getOperation().getType()) {
case Token.EQUAL:
    evaluateEqual(expression);
  break;
case Token.COMPARE_IDENTICAL:
evaluateBinaryExpression(compareIdenticalMethod,expression);
break;
case Token.COMPARE_EQUAL:
evaluateBinaryExpression(compareEqualMethod,expression);
break;
case Token.COMPARE_NOT_EQUAL:
evaluateBinaryExpression(compareNotEqualMethod,expression);
break;
case Token.FIND_REGEX:
evaluateBinaryExpression(findRegexMethod,expression);
break;
case Token.MATCH_REGEX:
evaluateBinaryExpression(matchRegexMethod,expression);
break;
case Token.COMPARE_GREATER_THAN:
evaluateBinaryExpression(compareGreaterThanMethod,expression);
break;
case Token.COMPARE_GREATER_THAN_EQUAL:
evaluateBinaryExpression(compareGreaterThanEqualMethod,expression);
break;
case Token.COMPARE_LESS_THAN:
evaluateBinaryExpression(compareLessThanMethod,expression);
break;
case Token.COMPARE_LESS_THAN_EQUAL:
evaluateBinaryExpression(compareLessThanEqualMethod,expression);
break;
case Token.LOGICAL_AND:
evaluateLogicalAndExpression(expression);
break;
case Token.LOGICAL_OR:
evaluateLogicalOrExpression(expression);
break;
case Token.PLUS:
evaluateBinaryExpression("plus",expression);
break;
case Token.MINUS:
evaluateBinaryExpression("minus",expression);
break;
case Token.MULTIPLY:
evaluateBinaryExpression("multiply",expression);
break;
case Token.DIVIDE:
evaluateBinaryExpression("divide",expression);
break;
case Token.KEYWORD_INSTANCEOF:
evaluateInstanceof(expression);
break;
default :
throw new ClassGeneratorException("Operation: " + expression.getOperation() + " not supported");
}
}
