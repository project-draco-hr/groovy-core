{
  reset();
  boolean complete=false;
  boolean done=false;
  while (!done) {
    try {
      pending=reader.readLine();
    }
 catch (    IOException e) {
    }
    if (pending == null) {
      return null;
    }
    String command=pending.trim();
    if (COMMAND_MAPPINGS.containsKey(command)) {
      int code=((Integer)COMMAND_MAPPINGS.get(command)).intValue();
switch (code) {
case COMMAND_ID_EXIT:
        return null;
case COMMAND_ID_HELP:
      displayHelp();
    break;
case COMMAND_ID_DISCARD:
  reset();
done=true;
break;
case COMMAND_ID_DISPLAY:
displayStatement();
break;
case COMMAND_ID_EXPLAIN:
explainStatement();
break;
case COMMAND_ID_BINDING:
displayBinding();
break;
case COMMAND_ID_EXECUTE:
if (complete) {
done=true;
}
 else {
err.println(MESSAGES.getMessage("command.execute.not_complete"));
}
break;
case COMMAND_ID_DISCARD_LOADED_CLASSES:
resetLoadedClasses();
break;
case COMMAND_ID_INSPECT:
inspect();
break;
default :
throw new Error("BUG: Unknown command for code: " + code);
}
continue;
}
freshen();
if (pending.trim().length() == 0) {
accept();
continue;
}
final String code=current();
if (parse(code)) {
accept();
complete=true;
}
 else if (error == null) {
accept();
}
 else {
report();
}
}
return accepted(complete);
}
