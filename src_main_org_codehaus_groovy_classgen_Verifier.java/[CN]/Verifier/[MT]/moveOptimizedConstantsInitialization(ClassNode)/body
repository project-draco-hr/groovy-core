{
  if (node.isInterface())   return false;
  final int mods=Opcodes.ACC_STATIC | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC;
  String name=SWAP_INIT;
  BlockStatement methodCode=new BlockStatement();
  node.addSyntheticMethod(name,mods,ClassHelper.VOID_TYPE,Parameter.EMPTY_ARRAY,ClassNode.EMPTY_ARRAY,methodCode);
  methodCode.addStatement(new BytecodeSequence(new BytecodeInstruction(){
    @Override public void visit(    MethodVisitor mv){
      final String classInternalName=BytecodeHelper.getClassInternalName(node);
      mv.visitInsn(ACONST_NULL);
      mv.visitFieldInsn(PUTSTATIC,classInternalName,"$callSiteArray","Ljava/lang/ref/SoftReference;");
    }
  }
));
  for (  FieldNode fn : node.getFields()) {
    if (!fn.isStatic() || !fn.isSynthetic() || !fn.getName().startsWith("$const$"))     continue;
    if (fn.getInitialExpression() == null)     continue;
    final FieldExpression fe=new FieldExpression(fn);
    if (fn.getType().equals(ClassHelper.REFERENCE_TYPE))     fe.setUseReferenceDirectly(true);
    ConstantExpression init=(ConstantExpression)fn.getInitialExpression();
    ExpressionStatement statement=new ExpressionStatement(new BinaryExpression(fe,Token.newSymbol(Types.EQUAL,fn.getLineNumber(),fn.getColumnNumber()),init));
    fn.setInitialValueExpression(null);
    init.setConstantName(null);
    methodCode.addStatement(statement);
  }
  return true;
}
