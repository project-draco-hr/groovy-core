{
  for (ClassNode current=sn; current != null; current=current.getSuperClass()) {
    List superClassMethods=current.getMethods();
    for (Iterator sit=superClassMethods.iterator(); sit.hasNext(); ) {
      final MethodNode superClassMethod=(MethodNode)sit.next();
      if ((superClassMethod.getModifiers() & ACC_STATIC) != 0)       continue;
      if (!superClassMethod.getName().equals(method.getName()))       continue;
      Map genericsSpec=createGenericsSpec(current);
      if (!equalParameters(method,superClassMethod,genericsSpec))       continue;
      ClassNode mr=method.getReturnType();
      ClassNode smr=superClassMethod.getReturnType();
      if (mr.equals(smr))       continue;
      ClassNode testmr=correctToGenericsSpec(genericsSpec,smr);
      if (!mr.isDerivedFrom(testmr)) {
        throw new RuntimeParserException("the return type is incompatible with " + superClassMethod.getTypeDescriptor() + " in "+ current.getName(),method);
      }
      if ((superClassMethod.getModifiers() & ACC_FINAL) != 0) {
        throw new RuntimeParserException("cannot override final method " + superClassMethod.getTypeDescriptor() + " in "+ current.getName(),method);
      }
      if ((superClassMethod.getModifiers() & ACC_STATIC) != (method.getModifiers() & ACC_STATIC)) {
        throw new RuntimeParserException("cannot override method " + superClassMethod.getTypeDescriptor() + " in "+ current.getName()+ " with disparate static modifier",method);
      }
      MethodNode newMethod=new MethodNode(superClassMethod.getName(),method.getModifiers() | ACC_SYNTHETIC | ACC_BRIDGE,superClassMethod.getReturnType(),superClassMethod.getParameters(),superClassMethod.getExceptions(),null);
      List instructions=new ArrayList(1);
      instructions.add(new BytecodeInstruction(){
        public void visit(        MethodVisitor mv){
          BytecodeHelper helper=new BytecodeHelper(mv);
          mv.visitVarInsn(ALOAD,0);
          Parameter[] para=superClassMethod.getParameters();
          Parameter[] goal=method.getParameters();
          for (int i=0; i < para.length; i++) {
            helper.load(para[i].getType(),i + 1);
            if (!para[i].getType().equals(goal[i].getType())) {
              helper.doCast(goal[i].getType());
            }
          }
          mv.visitMethodInsn(INVOKEVIRTUAL,BytecodeHelper.getClassInternalName(classNode),method.getName(),BytecodeHelper.getMethodDescriptor(method.getReturnType(),method.getParameters()));
          helper.doReturn(superClassMethod.getReturnType());
        }
      }
);
      newMethod.setCode(new BytecodeSequence(instructions));
      methodsToAdd.add(newMethod);
      return;
    }
  }
}
